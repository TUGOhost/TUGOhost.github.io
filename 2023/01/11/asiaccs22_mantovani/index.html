<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="摘要反编译器是用来从程序二进制恢复到高级语言表示（通常是C代码）的工具。在过去的五年中，反编译器有了很大的改进，不仅是在产生的伪代码的可读性方面，而且在恢复的相似性方面也有了很大的改进。尽管反编译器经常被不同学科的逆向工程师所使用 (例如，支持漏洞发现或恶意软件分析），它们还没有被用来为源代码静态分析工具提供输入。特别是，源代码漏洞发现和二进制漏洞发现在今天仍然是两个非常不同的研究领域，尽管反编译">
<meta property="og:type" content="article">
<meta property="og:title" content="[译文]源代码与二进制漏洞的融合">
<meta property="og:url" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/index.html">
<meta property="og:site_name" content="TUGOhost">
<meta property="og:description" content="摘要反编译器是用来从程序二进制恢复到高级语言表示（通常是C代码）的工具。在过去的五年中，反编译器有了很大的改进，不仅是在产生的伪代码的可读性方面，而且在恢复的相似性方面也有了很大的改进。尽管反编译器经常被不同学科的逆向工程师所使用 (例如，支持漏洞发现或恶意软件分析），它们还没有被用来为源代码静态分析工具提供输入。特别是，源代码漏洞发现和二进制漏洞发现在今天仍然是两个非常不同的研究领域，尽管反编译">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/1.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/2.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/3.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/4.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/5.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/6.png">
<meta property="og:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/7.png">
<meta property="article:published_time" content="2023-01-11T02:28:25.000Z">
<meta property="article:modified_time" content="2023-01-09T15:58:22.081Z">
<meta property="article:author" content="TUGOhost">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>[译文]源代码与二进制漏洞的融合</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/01/01/MIUI_PrivacyManager/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&text=[译文]源代码与二进制漏洞的融合"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&is_video=false&description=[译文]源代码与二进制漏洞的融合"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]源代码与二进制漏洞的融合&body=Check out this article: http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&name=[译文]源代码与二进制漏洞的融合&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&t=[译文]源代码与二进制漏洞的融合"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">2.</span> <span class="toc-text">关键词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SAST"><span class="toc-number">4.1.</span> <span class="toc-text">SAST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">反编译器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">方法和实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%92%8C%E5%BA%94%E7%94%A8%E9%80%89%E6%8B%A9"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞和应用选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SAST%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9"><span class="toc-number">5.2.</span> <span class="toc-text">SAST工具选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9"><span class="toc-number">5.3.</span> <span class="toc-text">反编译器选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.1.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">6.2.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BC%96%E8%AF%91"><span class="toc-number">6.3.</span> <span class="toc-text">重编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">反编译器的可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%91%98%E8%A6%81%EF%BC%9A%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%A7%AF%E6%9E%81%E5%9B%A0%E7%B4%A0"><span class="toc-number">6.5.</span> <span class="toc-text">结果摘要：真正的积极因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%91%98%E8%A6%81%EF%BC%9A%E5%81%87%E9%98%B3%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">结果摘要：假阳性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%85%E5%9C%A8%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%8A%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">6.7.</span> <span class="toc-text">仅在伪代码上检测到的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.8.</span> <span class="toc-text">编译器的影响</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        [译文]源代码与二进制漏洞的融合
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">TUGOhost</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-01-11T02:28:25.000Z" itemprop="datePublished">2023-01-11</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/C/" rel="tag">C++</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>反编译器是用来从程序二进制恢复到高级语言表示（通常是C代码）的工具。在过去的五年中，反编译器有了很大的改进，不仅是在产生的伪代码的可读性方面，而且在恢复的相似性方面也有了很大的改进。尽管反编译器经常被不同学科的逆向工程师所使用 (例如，支持漏洞发现或恶意软件分析），它们还没有被用来为源代码静态分析工具提供输入。特别是，源代码漏洞发现和二进制漏洞发现在今天仍然是两个非常不同的研究领域，尽管反编译器有可能弥合这一差距，并能对二进制文件进行源代码分析。</p>
<p>在本文中，我们在真实世界的漏洞上进行了一些实验，以评估这种方法的可行性。特别是，我们的测量旨在显示原始代码和反编译代码之间的差异如何影响静态分析工具的准确性。</p>
<p>值得注意的是，我们的结果显示，在71%的情况下，在反编译的代码上运行静态分析器可以检测到相同的漏洞，尽管在一些情况下我们观察到假阳性的数量急剧增加。为了了解这些差异背后的原因，我们对所有的案例进行了人工调查，我们发现了一些影响静态工具 “理解 “生成代码的能力的根本原因。</p>
<h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p> 反编译器，SAST，漏洞，逆向。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着我们的世界继续迅速加速进入以软件为动力的未来，日益支持我们的生活和生计的软件中的漏洞正在增加。这给软件开发和测试带来了一系列独特的挑战。软件往往由两类测试人员来检查是否有漏洞：一类是开发软件的人，因此可以接触到源代码（源码级程序分析）；另一类是外部安全研究人员，他们往往无法接触到源代码 往往不能接触到源代码（二进制程序分析）。</p>
<p>源码级的漏洞分析与二进制的漏洞分析有着本质的区别，因为软件的关键信息，如类型、结构和大小信息，在软件被编译时就会丢失。这使得在二进制代码上执行某些分析范式，如静态漏洞检测，成为一项艰巨的挑战：在检测二进制代码中的漏洞之前，必须以某种方式恢复这些丢失的信息。这就解释了为什么在这个方向上的工作很少，以及为什么能够分析二进制代码的商业工具（如Veracode）需要用调试符号编译应用程序（即，本质上需要源代码）。缺乏源代码也阻碍了其他分析范式，如模糊分析和符号执行，因为即使是这些技术也受益于编译的能力，而不是在分析目标中加装仪器。因此，静态分析技术往往需要源代码来有效地检测漏洞，而动态技术在有源代码时也能更好地发挥作用。</p>
<p>有趣的是，有一个相关的研究领域关注恢复编译过程中丢失的信息：反编译。近年来，人们提出了一些技术来改善数据类型、代码结构、甚至确切的语法特征的恢复。这些技术已经被整合到越来越强大、准确和公开可用的反编译器原型中。</p>
<p>我们的见解是，从概念上讲，反编译所离开的地方接近于漏洞检测的地方。也就是说，我们意识到，由反编译器恢复的类型信息、结构信息和伪代码可以被漏洞检测工具分析，以代替原始源代码，至少有一定的功效。此外，随着新兴技术不断改进反编译结果，原始代码和程序二进制反编译的伪代码之间的差距越来越小，反编译器可以成为基于源代码的漏洞检测技术的一个越来越有效的”拐杖”。</p>
<p>在本文中，我们进行了一项研究，以确定当前静态应用安全测试（SAST）工具在反编译器生成的代码上执行时检测漏洞的能力。虽然看起来很明显，反编译的代码仍然不适合静态分析，但我们的案例研究希望通过实验来量化我们离静态分析工具成为反编译代码的有效解决方案还有多远。为了做到这一点，我们测量了8个最先进的SAST工具的精度和召回率，因为它们在9个真实世界的应用程序的原始代码上操作，而这些应用程序的伪代码是由3个不同的最先进的反编译器反编译出来的。</p>
<p>我们的研究得出了四个主要结论。首先，当前反编译器的输出不适合大多数SAST工具在没有人类分析师干预的情况下进行任何分析，必须在基于编译的分析器（例如那些基于LLVM传递的分析器）应用之前进行修复。其次，当编译问题被手动修复时，SAST工具的运行召回率降低了71%，这表明在反编译器&#x2F;SAST中可能实际存在着一种潜在的潜力。不幸的是，SAST工具在反编译代码上的精确度受到影响，平均误报率增加了232%。第三，我们发现，编译器的优化，特别是函数的内联，有时可以帮助（而在其他时候，阻碍）SAST工具。第四，通过分析原始代码和反编译代码之间SAST结果的差异，我们确定并描述了影响假阳性和真阳性检测性能差异的7个根本原因。</p>
<p>反过来，我们设想了一些可以从我们的结果中得到启发的直接的前进步骤。我们的研究巩固了这样一种认识：现代反编译器的设计是为了生成对人类来说容易理解的代码，而SAST工具的设计则不是为了摄入这种机器生成的代码。这为研究人员提出了一系列新的方向：尽管反编译器在设计时考虑到了源代码的要求，但即使是对反编译器的微小改进也能极大地提高SAST工具对二进制代码的功效。另外，未来的研究可以集中在SAST工具上，使它们在解析反编译的代码时更具有抗噪音能力。例如，在我们的研究中表现良好的SAST工具之一Joern所执行的模糊解析方法已经朝这个方向发展了。此外，使用反编译器作为源码级静态分析的第一阶段，可以在我们的数据集上使用SAST工具以外的应用。例如，嵌入式设备固件仍然难以用动态（由于在不模拟特定硬件环境的情况下执行固件的困难，即所谓的重新托管问题）和静态（由于固件通常以二进制形式分布）技术进行测试。虽然在这两方面都取得了一些有限的进展，但反编译器辅助的静态分析器可以在没有标准替代品的情况下对这些情况进行自动化的漏洞评估。</p>
<p>综上所述，本文有三个主要贡献：</p>
<ul>
<li>我们将反编译和源码级静态分析 “连在一起”，意识到后者在接近前者的地方接续。</li>
<li>我们对具有已知漏洞的真实世界的应用程序进行了彻底的评估，测量了检测效率的变化。</li>
<li>我们分析了反编译代码的SAST分析所产生的问题的根本原因，并提出了反编译技术研究人员可以进行的具体改进，以改善端到端的SAST结果。</li>
</ul>
<p>所有与该论文相关的工件都存在于<br><a target="_blank" rel="noopener" href="https://github.com/elManto/SAST_on_Decompilers">https://github.com/elManto/SAST_on_Decompilers</a></p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>我们现在介绍与静态应用测试和反编译有关的技术现状。</p>
<h2 id="SAST"><a href="#SAST" class="headerlink" title="SAST"></a>SAST</h2><p>正如Chess等人所认为的，静态应用安全测试（SAST）的目的是在开发阶段消除源代码中的漏洞。</p>
<p>这个研究领域提出的第一个方法包括对源代码进行简单的词汇分析，旨在检测已知的脆弱结构（例如危险的API调用）的存在。</p>
<p>为了克服这些天真的技术的局限性，研究人员提出了新的方法，利用应用程序的源代码的更详细的模型，通常是依靠编译器的解析组件来获得。例如，作者提出不同的方法，在编译时提取源代码的AST，并将其用于漏洞检测。</p>
<p>其他研究人员则倾向于尝试提高对特定类别错误的检测精度。其中，缓冲区溢出、释放后使用和空指针解构就是这种情况。</p>
<p>也就是说，我们的论文并没有提出一种新的静态分析方法。相反，它更接近于许多专注于程序分析工具基准的研究，例如，在这些研究中，从创建一个全面的测试案例到在实验中采用不同的工具集等几个方面进行分析。</p>
<h2 id="反编译器"><a href="#反编译器" class="headerlink" title="反编译器"></a>反编译器</h2><p>关于反编译器的最早研究之一是由Cifuentes在1995年进行的，作为她博士论文的一部分，她描述了反编译器如何工作，该领域的未来挑战，并提出了dcc，一个用于英特尔80286的反编译器。</p>
<p>在过去的二十年里，出现了两种主要的反编译器开发方法：基于规则的反编译和基于NMT（神经机器翻译）的反编译。基于规则的方法是目前最流行的，尽管制作一个基于规则的反编译器特别耗时。例如，根据其作者的说法，RetDec的开发在一个由24名开发人员组成的团队中总共花费了7年时间。</p>
<p>基于NMT的方法的诞生与Katz等人的开创性工作相吻合，作者将反编译问题概括为一项语言翻译任务，即由于采用了自然语言处理（NLP），从汇编到C。</p>
<p>另一个研究方向是提高反编译代码的质量，主要集中在两个方面：提高可读性和改进控制流布局。第一类包括旨在更好地恢复变量类型和建议更有意义的变量名称的工作。第二类传统上侧重于减少反编译器（DREAM &#x2F;DREAM++反编译器）生成的GOTO语句的数量。</p>
<p>需要强调的是，所有这些研究都只关注于改善人类的可读性（也就是反编译器输出的可用性）。迄今为止，还没有任何研究分析过机器处理所产生的代码有多容易。</p>
<p>最后，在2018年，Schulte等人提出了一种新颖的方法来生成可以成功重新编译的二进制等价的反编译代码。Schulte等人的论文依赖于一些创新技术，如采用现有的反编译器作为提升过程的种子，并使用人写的代码摘录来生成人类可读的代码，即使该工具（名为BED）没有发布。</p>
<h1 id="方法和实验设计"><a href="#方法和实验设计" class="headerlink" title="方法和实验设计"></a>方法和实验设计</h1><p>本文从漏洞检测的角度，研究现代静态分析工具如何受到反编译过程的影响。为此，我们研究了以下实体的互动。SAST工具、易受攻击的应用程序和反编译器。</p>
<p>对于每个易受攻击的应用程序，我们按照图1的总结进行（由于篇幅原因在附录中报告），其中有两个主要管道被执行。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/1.png"></p>
<p><strong>基线分析</strong>。在源代码分析管道中，我们将应用程序的原始源代码输入到不同的静态分析器中，并存储其生成的报告供以后分析。</p>
<p><strong>编译</strong>。我们根据提供的构建脚本（如Makefiles）编译每个应用程序，使用与开发人员建议的相同的编译器选项，以获得编译后的二进制文件，进而送入反编译的代码分析管道。附录4.8提出了进一步的见解，在那里我们展示了我们对易受攻击的应用程序的一个子集进行的差异化分析的结果，以评估编译器优化的影响。</p>
<p><strong>反编译和分析</strong>。在反编译的代码分析管道中，我们使用我们的反编译器对二进制文件进行反编译，并通过不需要重新编译的SAST工具运行所得到的代码。</p>
<p>大多数的SAST工具需要编译目标应用程序（例如，执行LLVM传递）。因此，由于反编译器通常会产生类似于C语言的伪代码，而这些伪代码不能被重新编译，我们手动应用所需的修正，使反编译器的结果可以被gcc和clang编译器编译。这个耗时的过程是有趣的，原因有很多。首先，它使我们能够用我们研究中选择的所有静态分析工具完成实验。此外，它为我们提供了一个宝贵的反馈，即如果分析人员想在二进制程序上应用源代码静态分析，他们应该采取哪些步骤。换句话说，它使我们能够量化人类在环路解决方案的可行性和所需的努力。</p>
<p>在手动修复反编译的结果后，我们通过基于编译的SAST工具处理可重新编译的代码。</p>
<p><strong>结果比较</strong>。最后，我们对实验中获得的三组报告（关于原始源代码的报告，以及关于反编译和可重新编译代码的两组报告）进行人工比较，以评估检测率和假阳性率如何受到前面步骤的影响。这一比较的结果将在第4节中介绍。</p>
<p>每当结果不同时（即如果以前检测到的漏洞不再被检测到，或者如果工具产生了新的错误警报 工具产生了新的错误警报），我们进行了根本原因分析 以确定其原因。这个步骤也是手动进行的。要求我们逐步修改反编译后的代码，使其与原代码越来越相似。使其与原始源码越来越相似，直到我们想要研究的效果消失。直到我们想要研究的效果消失为止（即检测到漏洞或不再发出错误警报）。</p>
<p>在本节的其余部分，我们将讨论我们用来选择脆弱的应用程序、SAST工具和反编译器的方法。值得注意的是，应用程序和SAST工具必须一起选择。事实上，为了有足够的结果供我们比较，我们要求每个漏洞至少被两个SAST工具检测到，而每个SAST工具至少检测到两个漏洞。这个限制被证明是很难满足的，并迫使我们执行一个漫长的预选阶段，在这个阶段我们评估了许多候选者（包括漏洞和静态工具）。</p>
<h2 id="漏洞和应用选择"><a href="#漏洞和应用选择" class="headerlink" title="漏洞和应用选择"></a>漏洞和应用选择</h2><p>我们对脆弱代码的选择是由五个主要要求驱动的。</p>
<p><strong>代码库规模</strong>。我们希望包括一个小型的代码库，以评估代码复杂性对反编译和漏洞检测阶段的影响。检测阶段的影响。</p>
<p><strong>C++</strong>. We included a C++ codebase to evaluate the fact that decompilers only produce C code as output.</p>
<p><strong>真实的漏洞</strong>。我们想收集真实世界的 CVE 和 bug，它们可以适当地代表典型的 bug 类别。这将使我们在实际的评估阶段尽可能地通用，而不关注人为生成的漏洞。</p>
<p><strong>错误的复杂性</strong>。影响静态分析精度的一个重要因素是，需要检测的错误是程序间的（即，它的发现需要经过多个函数）还是程序内的（即，它在一个程序中是自成一体的）。在我们的数据集中，我们希望包括这两类的例子，更倾向于程序内的。事实上，我们的测试平台的目的不仅仅是为SAST工具设定基准，还包括具有不同检测复杂性的错误。</p>
<p><strong>漏洞的可发现性</strong>。最后，我们还受到一个事实的限制，即所选的漏洞应该由所选的SAST工具在原始源代码上识别，以便在观察反编译代码的判决时进行比较。</p>
<p>为了满足我们所有的限制条件，我们从九个不同的应用程序中收集了10个漏洞（表1）。这些应用的范围从4千到2.1百万LOC不等（所有LOC的统计数字在表4中报告）。请注意，对于两个项目，即Xorg和OpenCV，漏洞存在于应用程序的一个子组件中，可以被编译为一个独立的模块。我们的数据集涵盖了以下五类漏洞。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/2.png"></p>
<p><strong>缓冲区溢出BOF</strong>可能是最普遍的一类漏洞，这就是为什么我们决定在我们的评估中包括这类漏洞的五种变化，例如，对缓冲区处理API的三种错误使用（分别是scanf、memcpy和strcpy），一个基于堆的逐一缓冲区溢出的例子（程序间），最后是另一个基于堆的BOF。在一个C++代码库中，位于实现 父类中的一个抽象方法的实现。</p>
<p><strong>整数溢出IOF</strong>错误是软件中未定义行为的一个常见原因。我们的数据集包括一个IOF的例子，它影响了动态内存分配的大小，因此可能导致堆BOF。</p>
<p>当一个NULL指针被取消引用时，就会出现<strong>空指针定义 NPD</strong>错误。我们在数据集中包括了一个NPD的例子：在这个例子中，指针是由calloc调用返回的，它被存储在一个结构的字段中。这个错误是由于调用者没有检查指针的有效性。</p>
<p><strong>双重释放、释放后使用 DF、UAF</strong>漏洞。一方面，我们期望从反编译的角度来看，这种脆弱的缺陷更容易，因为反编译器可以在没有任何类型系统&#x2F;大小问题的情况下重构free的使用。另一方面，检测DF&#x2F;UAF的SAST工具需要在内部跟踪释放的指针并检查所有后续的指针访问。作为进一步的复杂性，这两个错误中的一个（DF），是两个程序间漏洞中的第二个。</p>
<p><strong>除以零 DBZ</strong>并不是一个内存损坏的漏洞，但它在过去影响了几个真实世界的软件，可以被用作拒绝服务漏洞。可被用作拒绝服务的漏洞。</p>
<h2 id="SAST工具选择"><a href="#SAST工具选择" class="headerlink" title="SAST工具选择"></a>SAST工具选择</h2><p>由于我们不确定反编译过程对SAST工具所进行的分析的影响，我们想评估一系列依靠不同功能和技术的产品。我们最初确定了12个工具（9个开源的，3个商业的）。</p>
<p>在12个候选的SAST工具中，我们选择了那些能够满足选择标准的工具，即在我们的数据集中检测到至少两个漏洞。 最后，我们的静态分析器集合，在表2中列出，包括。<a target="_blank" rel="noopener" href="https://github.com/danmar/cppcheck">CPPCheck</a>、<a target="_blank" rel="noopener" href="https://github.com/joernio/joern">Joern</a>、<a target="_blank" rel="noopener" href="https://github.com/facebook/infer">Infer</a>、<a target="_blank" rel="noopener" href="https://clang-analyzer.llvm.org/scan-build.html">Scan-build</a>、<a target="_blank" rel="noopener" href="https://github.com/NASA-SW-VnV/ikos">Ikos</a>、<a target="_blank" rel="noopener" href="https://github.com/github/codeql">Codeql</a>、Comm 1和Comm 2，这是两个流行的商业工具，由于法律原因，我们必须匿名。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/3.png"></p>
<p>在选择这八个工具之前，我们进行了一系列的初步实验，其中我们测试了许多其他的SAST工具。在其他工具中，我们考虑了Comm 3（另一个流行的商业工具）、Frama-C、CPACheck和Flawfinder。然而，我们放弃了它们，因为在对一个错误的子集执行后，它们没有显示出足够的检测率和分析的准确性。</p>
<h2 id="反编译器选择"><a href="#反编译器选择" class="headerlink" title="反编译器选择"></a>反编译器选择</h2><p>我们选择了三个最先进的反编译器进行评估。IDAPro 7.1（来自HexRays的最先进的商业反编译器），Ghidra 9.2（领先的开源反编译器），以及Retdec 4.0（新兴的挑战者）。</p>
<p>两个主要原因影响了我们对这三种工具的选择。首先，其他新出现的替代方案在精度和生成代码的质量方面都远远落后。此外，以前关于反编译器的工作在进行评估时只关注这三种反编译器。</p>
<p>非反编译提升器。一些工具，如MCSema，可以直接将二进制代码提升到LLVM IR，而不是反编译。乍一看，这些可能是在二进制代码上应用需要编译的SAST工具的一个可用途径。然而，这些工具只执行由反编译器执行的分析的一个子集，事实上，可以被视为反编译过程的 “第一阶段”。因此，与反编译器的结果相比，它们的输出将包含不充分的信息，使产生的代码不适合SAST分析。例如，由Lifters产生的字节码不包含调试信息，而在llvm pass之上工作的SAST工具通常需要编译器生成的符号。尽管有可能开发出更复杂的SAST工具，在静态提升器的输出和它们的预期输入之间架起桥梁，但这正是反编译器已经从另一个方向所做的。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>在这一节中，我们讨论了我们的实验，特别关注反编译过程是如何影响整个检测率和假阳性率的。误报率的影响，以及对每个工具的影响。我们把对这些结果背后的原因的调查留给下一节。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>表3报告了八个SAST工具在分析应用程序的原始源代码时对我们数据集中的不同漏洞的检测结果。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/4.png"></p>
<p>值得注意的是，除了Joern、Clang和Code-ql的显著例外，其他工具在错误检测方面相当互补，分别发现了2-4个错误，总体上只遗漏了两个错误（CVE-2017-17760和BUG-2018）。</p>
<p>Joern和Code-ql的高检测率是由于我们编写的自定义查询规则，并从这两个项目的作者[5, 15]描述的例子和指南中得到启发。尽管我们的范围不是生成一个足以涵盖某类漏洞的许多可能情况的通用查询，但我们试图把自己放在一个事先不知道该漏洞的分析师的位置上，这也解释了为什么用户定义的规则仍然产生了一些假阳性。</p>
<p>尽管我们的努力是为了产生通用规则，但不可避免地会引入一些偏见。然而，我们认为这是包括这两个分析器的唯一方法，这两个分析器代表了目前源代码静态分析的最先进水平，在我们的研究中。让查询更加通用以捕捉更多的特定类别的漏洞，也会导致有偏见的结果，因为会增加假阳性。相反的策略（即只捕捉测试中的漏洞的极其专门的查询）将不能代表现实世界中可以使用的规则，因为分析者事先不知道这些漏洞。</p>
<p>在我们的分析中包括的其余六个分析器是用它们自己的规则集启动的，因此它们没有在实验中引入任何偏见。特别是，我们决定不为其他工具（如Comm 2或Comm 1）创建自定义规则，因为它们已经配备了一整套规则，足以检测我们数据集中的一些漏洞。</p>
<h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>除了RetDec的两次执行因LLVM错误而在最大的项目（Wireshark和OpenCV）上失败外，所有三个反编译器都能成功反编译我们数据集中的九个二进制文件。要衡量生成的伪代码有多准确，甚至要衡量它与原始源代码有多接近，是非常困难的。为了完成这项任务，我们从[35, 64]的作者那里得到启发，他们采用代码行数和GOTO语句数作为核心指标来比较他们工作中的不同反编译器结果。作为一个粗略的指标，表4报告了代码行数的比较。在大多数实验中，HexRays的输出是最小的，与原始源文件相比，总共多出20.8%的代码行。Ghidra的代码也差不了多少（比原始文件多了26.2%），而RetDec则要啰嗦得多（在它成功运行的八个二进制文件中多了79.8%）。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/5.png"></p>
<p>以前关于反编译的论文经常把GOTO语句的数量作为衡量所生成代码 “质量 “的标准。虽然质量经常被用作可读性的同义词，而且目前还不清楚这是否会对静态分析工具产生任何影响，但较少的GOTO数量也可以被认为是更先进的反编译器的标志。我们注意到，所有的工具都产生了包含许多GOTO的代码，范围从最小的84个（HexRays on ytnef）到最大的36,002个（HexRays on Wireshark）。平均来说，HexRays每60.3个LOCs（原始源代码）就产生一个GOTO，Ghidra每60.7个就产生一个，RetDec每11.2个就产生一个。</p>
<p>最后，我们比较了项目源代码中的函数声明和三个反编译器产生的伪代码中的函数声明，以衡量输入参数数量的差异。平均而言，HexRays漏掉了4个参数，Ghidra漏掉了6个，RetDec漏掉了7个，每10个函数声明中就有一个。</p>
<h2 id="重编译"><a href="#重编译" class="headerlink" title="重编译"></a>重编译</h2><p>在我们的SAST工具中，有三个可以直接分析源代码文件，而不需要对其进行编译。前两个工具能够分析反编译器的输出，而无需任何进一步的人工干预。而Comm 2在重建五个反编译代码实例的AST时失败了。</p>
<p>此外，其余五个工具需要编译目标应用程序来分析它。然而，正如<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3395363.3397370">48</a>的作者所显示的，三个反编译器所产生的输出没有一个是正确的C代码，因此它们都不能被重新编译开箱即用。这使我们不得不寻找一个合适的解决方案来继续我们的实验。</p>
<p>因此，为了使自己处于分析者的位置，我们试图手动修正产生的伪代码，使其符合GCC和Clang的要求。我们对研究中考虑的所有三个反编译器的输出进行了这一操作，以比较静态分析器对不同输入伪代码的不同执行情况。</p>
<p>总的来说，人工程序花了至少90分钟到8小时（对于libyang）。然而，在花了24小时试图修复Wireshark和OpenCV（两个最大的项目）的反编译代码后，我们无法获得一个 “可重新编译 “的伪代码版本。因此，对于这两个应用程序，我们采用了另一种解决方案，它允许我们生成一个反编译的应用程序的版本，保留了漏洞，并可以被我们的SAST工具处理。特别是，对于这两种情况，我们固定了有漏洞的函数和它们调用的所有程序的伪代码。然后，我们将这些代码整合到有漏洞的模块的原始源代码中–这样就形成了一个混合代码库，其中所有与漏洞有关的代码都来自反编译器，而其余部分则逐字逐句地取自该模块的原始代码库。这种妥协使我们能够研究SAST工具是否仍能在可重新编译的代码中找到漏洞，从而将我们对这些工具的评估扩展到所有预选的漏洞，但不能测量其对整个误报数量的影响。</p>
<p>我们的手动程序由一些重复的步骤组成，涉及全局变量的正确定义、头文件的定义、函数调用的纠正（例如，经常是反编译器声明了一个有N个参数的方法，却用M！&#x3D;N个参数来调用它）、解决类型不匹配的问题，以及一些小的语法操作来删除错误的关键词或用括号修复语法错误。</p>
<p>尽管我们意识到在手动修正伪代码时可能会引入一些偏见，但我们想强调的是，这模拟了一个现实的环境，因为目前这种方法需要一个人在环中的解决方案，而替代方案仍然缺失。</p>
<h2 id="反编译器的可变性"><a href="#反编译器的可变性" class="headerlink" title="反编译器的可变性"></a>反编译器的可变性</h2><p>能够分析三种反编译器输出的SAST工具的检测结果在表6的 “反编译器输出”栏中列出。这些结果没有对三种反编译器中的每一种进行细分，因为除了下面讨论的CVE-2017-6298的情况外，无论哪种反编译器的检测结果都是一样的。</p>
<p>事实上，我们为每个版本的反编译代码启动了8个静态分析器（根据工具的不同，可以是原始的，也可以是手动修复的）。不幸的是，一些分析器-伪代码的组合不能产生分析结果，因为相应的工具以崩溃而失败。除了Ikos对CVE-2019-1010315的Hex-Rays反编译的执行之外，其他例外情况主要影响了Ikos分析时Ghidra和Reddec的输出（Reddec有3次失败，Ghidra有5次），Comm 1（Reddec有2次失败）和Comm 2（Reddec有3次失败，Ghidra有2次）。对于所有其他工具，有可能比较检测方面的输出，发现从SAST的角度来看，HexRays和Ghidra的结果之间没有差异。</p>
<p>总的来说，RetDec生成的代码更加复杂，对于人类分析员来说，可读性大大降低。然而，可读性并不一定影响自动算法，事实上，只有在使用Joern和Code-ql时，才能在RetDec的输出中检测到CVE-2017-6298漏洞。这是由于RetDec采用了一种更天真的方法，将结构的字段当作独立的变量来表示（而Ghidra和HexRays都是重构结构），然后再将它们分配到结构的伪代码表示中（即数组）。正如我们将在第5节详细解释的那样，这有助于静态分析工具更容易地跟踪各个字段的使用，在上述案例中，这有助于发现漏洞。</p>
<p>我们搜索了其他包含结构的案例，看看它们是否也受益于RetDec的反编译方法，但是在RetDec反编译的代码上，既没有发现Use-after-free，也没有发现与结构使用有关的Double free bug。请注意，由于RetDec未能完整地反编译Wireshark，我们手动尝试将工具直接指向易受攻击的函数（已被RetDec反编译），但这并没有导致任何检测，因为在这些情况下，生成的代码与HexRays的代码更相似，它包含一些模式，使错误检测更难。正如我们将在第5章中详细解释的那样，类型和结构在伪代码中的表示对于SAST工具是至关重要的。</p>
<p>在本文的其余部分，如果至少存在一个反编译的代码，使工具在分析时能识别出易受攻击的缺陷，我们就认为这是静态分析器在二进制上检测到的缺陷。同样，由于篇幅限制，对于表6（我们在这里评估假阳性的变化），我们只报告HexRays反编译代码的结果。此外，考虑到一些工具在Retdec和Ghidra上遇到的失败情况，对这些工具的误报评估将是不完整的。</p>
<h2 id="结果摘要：真正的积极因素"><a href="#结果摘要：真正的积极因素" class="headerlink" title="结果摘要：真正的积极因素"></a>结果摘要：真正的积极因素</h2><p>表5给出了一个结果的总结，包括我们能够在反编译器的虚构输出上运行的工具，以及我们必须在手工策划的代码上测试的其余工具。绿色标记代表了在伪代码上发现错误的情况，而交叉标记则表示缺少检测。而破折号则表示在原始源代码和反编译代码中都没有发现该错误。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/6.png"></p>
<p>我们必须强调，在对原始HexRays反编译代码的五次执行中，Comm 2未能构建分析代码的AST。由于这个原因，我们选择在可重新编译的代码上运行它，并报告与这些执行有关的结果。</p>
<p>总的来说，只有一个工具（Chechmarx）能够重新发现与应用于原始源代码时一样的漏洞子集。然而，所有的工具仍然能够发现至少一个漏洞（而且往往不止一个），从而表明在反编译的代码上运行SAST工具并不是一个无用的程序。总的来说，在反编译后，原始代码库上的42个累积真阳性下降到30个（71%）。然而，并非所有的工具都受到同样的影响，正如表的最后一行所报告的那样。</p>
<p>在源代码上操作而不需要编译的三种工具受反编译过程的影响较小。此外，商业工具虽然在发现我们的数据集中的漏洞方面总体上不太有效，但在反编译的代码中也继续发现完全相同的错误，尽管在Comm 1的情况下，我们可以观察到一个新的漏洞被发现，而不是另一个不再被发现的漏洞。在光谱的另一端，Clang和Code-ql是受反编译过程影响最大的两个工具。</p>
<p>看待数据的另一种方式是将结果按漏洞分组，而不是看不同的工具。在这种情况下（表5最后一列报告的所有结果），整数溢出（BUG-2012）、使用后自由（BUG-2010）和双重自由（BUG-2018）显然是在反编译代码上最难检测的。</p>
<p>在光谱的另一端，除以0和基于堆栈的缓冲区溢出似乎反而最容易检测。对于第一个问题，人工检查显示，在反编译器重建源代码的方式上没有有趣的变化。该错误涉及两个整数变量，对于反编译器来说，这比字符串&#x2F;指针更容易处理。因此，在对相应的二进制文件进行反编译后，从静态分析的角度来看，围绕漏洞的伪代码与原始代码相当相似。</p>
<p>对于三个基于堆栈的BOF，真正的阳性反而是以更多的假阳性为代价的，我们将在下一节中详细描述。对于这些情况，我们报告了一个星号（*），意味着大量的缓冲区操作被分析器标记，部分解释了这些情况的检测。</p>
<h2 id="结果摘要：假阳性"><a href="#结果摘要：假阳性" class="headerlink" title="结果摘要：假阳性"></a>结果摘要：假阳性</h2><p>一个工具的可用性在很大程度上由假阳性的数量决定，因为报告成千上万的警报会使分流阶段既困难又耗时。</p>
<p>我们对每个项目的假阳性增量进行了研究，我们可以比较这些工具对反编译代码的结果。因此，我们决定把重点放在Hex-Rays的输出上，因为这是一个更容易解析的输出。对于SAST工具来说，CVE-2019-1010315只报告了一次失败。 1010315（正如第4.4节中所解释的，3个工具在 Ghidra&#x2F;Retdec的输出）。此外，它不可能有 在Wireshark和OpenCV项目上进行这样的比较。因为我们无法重新编译反编译后的代码。</p>
<p>我们在表6中报告了错误警报的变化，用红色标记了错误警报增加超过50%的情况，用绿色标记了数量减少的情况。总的来说，如果我们不包括Joern（这是一个特殊的案例，我们将在下面描述），在78%的测试中，误报的数量增加。更糟糕的是，在61%的测试中，错误警报增加了50%以上。</p>
<p><img src="/2023/01/11/asiaccs22_mantovani/7.png"></p>
<p>我们指出，我们手动检查了静态分析器产生的警报，以评估它们是否代表实际的误报。我们为加快程序所做的唯一假设是，如果使用API调用（例如strcpy或memcpy）在源代码中是安全的，那么它在伪代码中就不可能成为漏洞。此外，许多误报可以被批量丢弃，因为它们与未初始化的变量有关。</p>
<p>然而，在某些情况下（主要是Clang和Comm 1），这些工具对反编译的代码产生的错误警报较少。为了弄清这背后的原因，我们检查了那些报告有负面变化的工具的报告。这种行为的主要原因之一是，源代码中的许多错误警报是由于自由相关的漏洞（UAF、DF、堆栈变量被释放）。然而，当分析反编译器时，SAST工具不能应用相同的数据流，此外，反编译器改变了包含释放的内存区域的变量类型，使分析器的工作更加困难。此外，有几个警告报告说源代码中出现了终止不良的字符串（即，没有适当空尾的字符串没有适当的空结尾的字节）。由于类型混淆的问题，同样的问题在反编译后的代码中无法检测出来。</p>
<p>为了评估Code-ql的假阳性率，我们采用了安装时提供的默认查询。这使我们能够获得无偏见的结果，与我们使用自己编写的自定义规则来查找漏洞的情况相比，我们会得到更多的结果。</p>
<p>最后，Joern值得单独讨论，因为该工具没有任何预定义的规则，因此所有的测试都是通过为每个项目扫描启用我们自己的启发式检查器来进行的。尽管这些肯定不是一个完整和通用的集合，但它们允许我们对这个静态分析器的假阳性也有一个合理的评估。此外，这样的工具会对代码进行模糊解析。即使这个特点使Joern成为分析反编译代码的完美候选者。<br>我们在某些情况下为这个事实付出了代价，它不能正确地解释某些代码片断，并跳过它们而不提供完整的分析。因此，内部表示法缺少一些无法正确解析的部分，因此我们的查询无法到达。这导致了查询输出的减少，因为只有一部分的代码可以被正确分析。</p>
<h2 id="仅在伪代码上检测到的错误"><a href="#仅在伪代码上检测到的错误" class="headerlink" title="仅在伪代码上检测到的错误"></a>仅在伪代码上检测到的错误</h2><p>我们最初的假设是，在反编译的代码上运行SAST工具，最多只能检测到与它用来分析应用程序原始源代码时相同的漏洞（更有可能比这少得多）。尽管我们的实验表明，对于大多数被分析的情况，这个假设是正确的，但我们发现了一个有趣的案例（BUG-2018），其中的工具（Joern和Comm 1）可以在反编译的代码上检测到一个漏洞，但在原始代码库中却没有。</p>
<p>编译器可以影响程序的控制流，以至于不可能完全恢复原来的版本。例如，我们将在下一小节中看到，有时编译器会出于优化的原因，删除死代码或简化布尔条件。</p>
<p>Wireshark（BUG-2018）中存在的双自由漏洞是一个程序间的问题，因此对于静态分析工具来说更难检测。事实上，正如清单1所报告的（由于篇幅原因，我们在附录中报告），该漏洞涉及三个独立的函数，最终调用了两次g_free。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">string_fvalue_free</span><span class="params">(<span class="type">fvalue_t</span> *fv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g_free</span>(fv-&gt;value.string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">val_from_string</span><span class="params">(<span class="type">fvalue_t</span> *fv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string_fvalue_free</span>(fv);</span><br><span class="line">    <span class="keyword">return</span> True;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">gboolean</span></span><br><span class="line"><span class="function"><span class="title">val_from_unparsed</span><span class="params">(<span class="type">fvalue_t</span> *fv, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string_fvalue_free</span>(fv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">value_from_string</span>(fv, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原始代码库中，Joern只能够重建导致自由的流程的一个子集，因此错过了这个漏洞。同样地，Comm 1进行的内部分析也不足以发现原始源代码中的漏洞流。</p>
<p>然而，在检查了反编译的代码后，我们注意到，由于静态关键字的存在，编译器将不同的函数内联到一个主体中（val from unparsed）。这就把程序间的错误变成了程序内的错误，很大程度上简化了检测错误的任务。事实上，事实证明，Joern和Comm 1在他们能够分析的伪代码上都成功地揭示了这个错误。</p>
<h2 id="编译器的影响"><a href="#编译器的影响" class="headerlink" title="编译器的影响"></a>编译器的影响</h2><p>编译器支持不同的优化水平，这些优化水平在汇编层面上修改了编译阶段的输出。因此，我们选择分析这些编译器选项如何影响反编译的结果，特别是分析伪代码的这种变化对SAST工具是否有意义。</p>
<p>为了验证这一点，我们根据以下四个阶段进行了一个额外的实验。(i) 选择：我们在开源项目中选择了两个，file和libssh2（CVE-2017-1000249和BUG-2012）。对这两个项目的选择是由其代码库的平均规模和有意义的检测数量驱动的。(ii) 用优化级别编译：我们用三种不同的优化级别编译所选项目，即O0、O2、O4（O0禁用所有优化通道，而O4表示生成的代码被高度优化以提高执行速度）。应该注意到，到目前为止讨论的所有实验都是使用每个项目的makefile中指定的默认编译器优化进行的（对于我们的应用总是O2）。(iii) 反编译：我们用HexRays对同一二进制文件的三个版本进行反编译。(iv) 分析：我们在每个反编译的结果上启动所有的SAST工具。这也意味着我们必须手动修复反编译代码的所有变体，以生成我们许多工具所要求的可重新编译的版本。</p>
<p>我们想研究的第一个方面是编译器选项如何影响假阳性的数量。所有的静态分析器都在所有的版本上运行，只有Ikos在解析用O4选项编译的代码时报告了一些问题。因此，在计算误报时，我们舍弃了它。</p>
<p>对于libssh2，这些工具分别在O0、O2和O4下累计产生了850、2421和1606个误报。对于文件，我们反而得到了3,085、2,275和2,984个警报，这取决于编译器的优化。这样的结果表明，没有明显的趋势，不清楚对代码进行更积极的优化是否会导致更多或更少的错误警报。然而，每个编译选项的误报量不同，意味着编译器实际上对生成的反编译代码有影响，因此，对SAST工具的解析方式也有影响。</p>
<p>然后，我们检查了这些工具生成的所有报告，以确定漏洞检测是否也受到编译器优化的影响。对于BUG-2012，我们无法发现静态分析工具在不同版本的反编译代码中的执行情况有任何不同。唯一能带来检测的配置是在代码的O0和O2版本上执行Ikos。在对这三种类型的伪代码进行人工检查后，我们了解到，除了声明变量的数量不同（O0为29个，O4为99个），编译器的优化水平并没有对脆弱的函数产生明显的影响。</p>
<p>CVE-2017-1000249却讲述了一个不同的故事。事实上，当扫描这三个版本时，工具报告了不同的结果，这取决于编译器的优化。更具体地说，在O0和O2的情况下，8个工具中有4个可以检测到这个错误。令人惊讶的是，在使用O4标志时，检测率下降到了零。为了理解这种急剧变化背后的原因，我们再一次查看了反编译的代码。第一个区别是，使用O4标志时，多个函数被内联编译，因此，有漏洞的函数成为一个更大的函数的一部分，阻碍了SAST工具对数据流的分析。此外，这样的修改不仅影响到二进制的本地定义函数，而且还影响到一些库函数。其中，原本包含在代码中的、导致缓冲区溢出的根本原因的memcpy调用被替换为一个内联实现，被工具忽略了。最后，由于优化的原因，一个对缓冲区大小的不安全的检查总是被评估为真（因为一个编程错误），被删除了，在第5节有更详细的描述。累积起来，这三个方面使SAST工具的工作变得非常困难，导致假阴性的增加。</p>
<p>虽然这个实验不能系统地发现编译器影响所产生的伪代码的所有可能情况，但这些观察表明，编译器对反编译阶段的假阳性和假阴性都有影响。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">2.</span> <span class="toc-text">关键词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SAST"><span class="toc-number">4.1.</span> <span class="toc-text">SAST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">反编译器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">方法和实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%92%8C%E5%BA%94%E7%94%A8%E9%80%89%E6%8B%A9"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞和应用选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SAST%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9"><span class="toc-number">5.2.</span> <span class="toc-text">SAST工具选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E6%8B%A9"><span class="toc-number">5.3.</span> <span class="toc-text">反编译器选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.1.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">6.2.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BC%96%E8%AF%91"><span class="toc-number">6.3.</span> <span class="toc-text">重编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">反编译器的可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%91%98%E8%A6%81%EF%BC%9A%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%A7%AF%E6%9E%81%E5%9B%A0%E7%B4%A0"><span class="toc-number">6.5.</span> <span class="toc-text">结果摘要：真正的积极因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%91%98%E8%A6%81%EF%BC%9A%E5%81%87%E9%98%B3%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">结果摘要：假阳性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%85%E5%9C%A8%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%8A%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">6.7.</span> <span class="toc-text">仅在伪代码上检测到的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.8.</span> <span class="toc-text">编译器的影响</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&text=[译文]源代码与二进制漏洞的融合"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&is_video=false&description=[译文]源代码与二进制漏洞的融合"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]源代码与二进制漏洞的融合&body=Check out this article: http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&title=[译文]源代码与二进制漏洞的融合"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&name=[译文]源代码与二进制漏洞的融合&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2023/01/11/asiaccs22_mantovani/&t=[译文]源代码与二进制漏洞的融合"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2023
    TUGOhost
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
