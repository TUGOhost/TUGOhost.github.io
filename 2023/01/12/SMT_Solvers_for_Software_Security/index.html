<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="摘要现代硬件的计算能力和算法的进步使得SAT求解成为一种可操作的技术，可以依靠它来决定工业软件的属性。在这篇文章中，我们介绍了SAT在软件安全方面的三个实际应用：静态漏洞检查、漏洞生成和复制保护的研究。这些领域在理论研究和实际解决方案方面都是最活跃的。调查解决这些问题的方法的成功和失败，对于指导未来关于这些问题本身以及其他基于SMT的系统的工作具有指导意义。 简介可满足性（SAT）是一个可解码的计">
<meta property="og:type" content="article">
<meta property="og:title" content="[译文]用于软件安全的SMT解算器">
<meta property="og:url" content="http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/index.html">
<meta property="og:site_name" content="TUGOhost">
<meta property="og:description" content="摘要现代硬件的计算能力和算法的进步使得SAT求解成为一种可操作的技术，可以依靠它来决定工业软件的属性。在这篇文章中，我们介绍了SAT在软件安全方面的三个实际应用：静态漏洞检查、漏洞生成和复制保护的研究。这些领域在理论研究和实际解决方案方面都是最活跃的。调查解决这些问题的方法的成功和失败，对于指导未来关于这些问题本身以及其他基于SMT的系统的工作具有指导意义。 简介可满足性（SAT）是一个可解码的计">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tugohost.github.io.com/img/9.png">
<meta property="og:image" content="http://tugohost.github.io.com/img/10.png">
<meta property="article:published_time" content="2023-01-11T18:00:25.000Z">
<meta property="article:modified_time" content="2023-10-15T12:07:47.014Z">
<meta property="article:author" content="TUGOhost">
<meta property="article:tag" content="论文翻译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tugohost.github.io.com/img/9.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>[译文]用于软件安全的SMT解算器</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     --><!--
       --><li><a href="/books/">Books</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/01/17/android_protect_shell/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/01/11/asiaccs22_mantovani/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&text=[译文]用于软件安全的SMT解算器"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&is_video=false&description=[译文]用于软件安全的SMT解算器"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]用于软件安全的SMT解算器&body=Check out this article: http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&name=[译文]用于软件安全的SMT解算器&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&t=[译文]用于软件安全的SMT解算器"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞利用生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BF%9D%E6%8A%A4%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">复制保护分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">3.</span> <span class="toc-text">漏洞检测中的SMT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用生成中的SMT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E6%A8%A1%E5%9E%8B%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">4.1.</span> <span class="toc-text">受限模型漏洞的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E7%89%88"><span class="toc-number">4.1.1.</span> <span class="toc-text">漏洞模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%88%B6%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84AEG"><span class="toc-number">4.1.2.</span> <span class="toc-text">有限制性模型的AEG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AEG%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.3.</span> <span class="toc-text">AEG的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BApayload"><span class="toc-number">4.2.</span> <span class="toc-text">自动创建payload</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">5.</span> <span class="toc-text">保护分析中的SMT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E5%8E%BB%E6%A8%A1%E7%B3%8A%E5%8C%96%E7%BB%93%E6%9E%9C%E7%9A%84%E7%AD%89%E4%BB%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">5.1.</span> <span class="toc-text">用于验证去模糊化结果的等价检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESMT%E7%9A%84%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E7%9A%84%E8%BE%93%E5%85%A5%E5%B7%A5%E8%89%BA"><span class="toc-number">5.2.</span> <span class="toc-text">基于SMT的半自动密码分析的输入工艺</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        [译文]用于软件安全的SMT解算器
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">TUGOhost</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-01-11T18:00:25.000Z" class="dt-published" itemprop="datePublished">2023-01-12</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" rel="tag">论文翻译</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现代硬件的计算能力和算法的进步使得SAT求解成为一种可操作的技术，可以依靠它来决定工业软件的属性。在这篇文章中，我们介绍了SAT在软件安全方面的三个实际应用：静态漏洞检查、漏洞生成和复制保护的研究。这些领域在理论研究和实际解决方案方面都是最活跃的。调查解决这些问题的方法的成功和失败，对于指导未来关于这些问题本身以及其他基于SMT的系统的工作具有指导意义。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>可满足性（SAT）是一个可解码的计算问题，其结构如下：给定一个布尔公式，是否存在一个变量的估值，对该公式来说是真的？如果存在这样的估值，这个公式就被称为可满足性。如果没有这样的估值，那么这个公式就被称为不可满足。SAT的复杂性是NP完整的，这意味着没有有效的算法来解决这个问题的所有实例。因此，各种启发式算法被用来降低实践中决策程序的执行时间。然而，SAT问题是积极研究的对象，因为更多的优化策略被精心设计，每年都有更大规模的实验取得结论性的结果。最近，SAT求解器已经成为一种更有表现力的约束规范和求解方法背后的驱动引擎。可满足性理论（Satisfiability Modulo Theories，SMT）问题扩展了SAT问题，支持更高层次的理论，如比特向量算术等，以及关系运算符，如平等。由于这些更高层次的概念，SMT允许对代码的语义进行更自然的建模，因此在对软件应用的属性进行推理时，通常会用SAT代替。在本文中，我们研究了SMT求解器作为黑盒神谕的实际应用，以回答编码静态漏洞检查、漏洞生成和复制保护分析等问题的本质。我们表明，SMT求解器是决定许多关于程序的重要安全问题的方便工具。尽管如此，贯穿始终的一个关键点是约束条件生成和约束条件求解之间的分离。解算器并不负责约束条件的生成步骤，但如果不能生成准确模拟被检查系统属性的约束条件，就会限制解算器所能提供答案的相关性。约束生成步骤被称为推理问题。推理包括从对分析程序的检查中自动生成约束。这些约束被传递给SMT求解器来解决。在函数式编程和编译器[28]中对约束的生成和解决进行了研究，但在与软件安全有关的应用中研究得较少[9]。虽然人们可能期望解决是基于SMT求解器的系统的瓶颈，但我们将在后面讨论，在许多情况下，约束生成的问题目前是主要的限制因素。</p>
<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>在过去的十年里，将程序验证工具部署到工业软件上取得了一些成功。程序验证的主要技术是定理证明[3]、抽象解释[12]和模型检查[11]。在这篇文章中，我们重点讨论了基于定理证明的安全漏洞检查，使用HAVOC[21]工具对用C语言编写的指令性程序进行检查。定理证明是一种成熟的技术，已经被应用于验证无调用、无循环程序和大型硬件系统[22]。由于全局分析技术，如谓词抽象[4]，定理证明在软件中的应用是比较新的。谓词抽象是一种潜在的分歧但自动化的技术，用于推断程序和循环边界的约束。基于谓词抽象的软件模型检查工具（如SLAM[4]）已经为软件的自动分析带来了相当大的价值，在中型驱动中发现了数百个软件错误。为了解决由模型检查引起的状态空间爆炸问题所带来的可扩展性问题，人们设计了Houdini算法[17]来回答单项式谓词抽象的问题。Houdini是一种简单而强大的技术，它基于候选契约（也可能是约束），允许用户提供简单的约束模板，并使用定点算法中的约束解算器来确定这些约束在函数或循环边界是否总是成立。Houdini是在Boogie验证框架[24]中实现的，HAVOC是该框架的一个前端。虽然Houdini是一个终止性和确定性的算法，但它无法回答存在性查询，因为候选约束只有在每个函数上下文中都成立时才会被持久化。因此，Houdini不能用来回答以下问题：在某些情况下，参数p持有值v是否可行？另一方面，它可以回答这样的问题：是否可以证明参数p总是具有价值v？</p>
<p>第2节用一个基于Sendmail漏洞[33]的简单而非琐碎的循环程序来说明C语言程序的推理问题，SMT求解器在决定给定程序点的一组约束条件的可满足性方面做得很好，但没有提供一个机制来自动合成所需的约束。虽然Houdini能够推理出候选的循环不变量，但自动推断出这种复杂的不变量是不可能的。因此，反馈给求解器的约束条件通常由专家分析员提供，或者使用有限的策略生成。</p>
<h2 id="漏洞利用生成"><a href="#漏洞利用生成" class="headerlink" title="漏洞利用生成"></a>漏洞利用生成</h2><p>漏洞利用生成是一个比漏洞检查更近的研究领域。迄今为止的工作主要分为两类–尝试自动生成旨在劫持系统控制流的输入[6, 20, 1]和尝试自动生成恶意的有效载荷[29, 34, 16, 32]。前一类的工作依赖于符号&#x2F;concolic执行系统[35, 7, 10, 5]来进行约束生成。这种系统跟踪符号输入数据和程序内存及CPU寄存器中所有其他字节之间的语义关系和约束。利用这些信息，就有可能生成SMT公式，对这些字节的潜在值提出问题。攻击生成系统已经利用这种能力来检查对应于潜在敏感指针的数据是否可以被攻击者控制。到目前为止，该领域解决的问题都是简化的方案，即禁用常见的操作系统安全措施和二进制加固技术。这些限制是必要的，其原因将在第3.1节讨论。</p>
<p>对恶意payload的生成进行的研究在解决现实世界的问题实例方面取得了更大的成功。为了本文的目的，我们将漏洞的有效载荷定义为一旦应用程序的控制流被劫持后执行的代码。到目前为止，作为开发研究的一部分产生的有效载荷是面向返回的编程（ROP）小工具的序列。一个小工具是一个指令序列，在目标程序的共享库或可执行程序中，执行一些有用的计算，最后将控制流转移到序列中的下一个小工具。这种小工具的集合通常是连锁在一起的，以完成一个特定的任务，如改变一个内存段的权限，复制一个第二阶段的有效载荷，然后执行该第二阶段。这种执行恶意代码的方法对于处理保护机制是必要的，这些保护机制阻止人们执行已经放在堆栈或堆上的代码。相反，通过执行程序代码中的指令序列，这种机制可以被避免，有时可以完全禁用。</p>
<p>SMT求解器已经被用作证明所需计算和指令序列之间功能等价的系统的推理部分[34]。它们也构成了端到端ROP编译器的一部分[16, 32]，该编译器试图自动地将这些小工具的序列串联起来，以便该序列在语义上等同于模型的有效载荷。这些系统通常将SMT求解器作为一个更大的算法集的一小部分。第3.2节讨论了这两种方法以及它们对SMT求解器的整合。与SMT求解器的其他许多成功应用一样，重点是减少最多查询的次数，并通过其他算法对求解器的输入进行预处理，以降低每个查询的复杂性。</p>
<h2 id="复制保护分析"><a href="#复制保护分析" class="headerlink" title="复制保护分析"></a>复制保护分析</h2><p>在复制保护领域，我们考虑了混淆程序的等价检查和自动密码分析这两个问题。我们发现，与前面提到的漏洞检查和漏洞生成领域类似，所面临的主要问题不是将约束系统送入SMT求解器，而是如何首先从程序中生成约束系统（以及生成哪种约束系统）。对于我们应用等价检查来验证虚拟化混淆器的去混淆器的正常工作，使用SMT求解器是很容易做到的。如果我们想应用同样的方法来简单地验证一个虚拟化的程序与它的原始版本是等价的，我们就会遇到围绕混淆版本中的输入依赖分支的问题。对于我们的自动密码分析应用，存在的问题是如何正确地对具有输入依赖性分支的代码进行建模，特别是对无界量的输入依赖性循环。其他程序分析技术，如不变推理，可以为这些问题提供解决方案，但它们属于推理阶段，与系统的实际解法是正交的。</p>
<h1 id="漏洞检测中的SMT"><a href="#漏洞检测中的SMT" class="headerlink" title="漏洞检测中的SMT"></a>漏洞检测中的SMT</h1><p>在这一节中，我们使用验证工具HAVOC（C和C++程序的堆感知验证器）来翻译成中间形式的Boogie，然后调用SMT求解器Z3来决定一个脆弱的程序和一个非脆弱的程序。为了简洁起见，我们没有明确说明将源代码转换为中间表示形式（IR）的步骤，而是直接进入公式的构建。Boogie IR是基于静态单一赋值形式（SSA）的，这使得构建传递给求解器的最终公式更加容易。我们使用图1中的代码片段，这是Mark Dowd在2003年发表的Sendmail crackaddr漏洞的简化版本。这个例子包含一个非复杂的循环程序，解析一个不受信任的字符串参数。</p>
<p>由于缺少对ulimit变量的递减，在第36行存在缓冲区溢出的漏洞。对这个循环的正确修复是在第28行启用这种递减。乍一看，这个循环的验证似乎相当复杂。关于这个循环的结构的一些关键性评论对于理解这个函数的行为是很重要的。首先，该函数包含两个状态变量quotation和rquote，对应于变量c所指向的当前处理的字符的值。这两个状态变量在循环的初始状态下保持False的值。只有少量的状态值组合是可能的，这是因为循环中的内部条件是相互排斥的，因为变量c的值在循环的同一迭代中不会改变。关于这个循环的第二个基本评论是关于ulimit变量。在第7行分配的这个变量的初始值指向本地缓冲区的偏移量15（因为BUFFERSIZE等于25）。根据所处理的输入字符串，这个值可以被递增或递减。可以用一个有限状态自动机来模拟循环的预期行为，对应其计算的预期和有效结果（启用第28行）。在这里，我们将循环的状态建模为（bool,bool,int）类型的三要素，对应于变量quotation、rquote的值和upperlimit-lbuf的值，如图1所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERSIZE 25</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_it</span><span class="params">(<span class="type">char</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> lbuf[BUFFERSIZE];</span><br><span class="line">    <span class="type">char</span> c, *p = input, *d = &amp;lbuf[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span> *ulimit = &amp;lbuf[BUFFERSIZE<span class="number">-10</span>];</span><br><span class="line">    <span class="type">int</span> quotation = FALSE;</span><br><span class="line">    <span class="type">int</span> rquote = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(lbuf, <span class="number">0</span>, BUFFERSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = *p++) != ’\<span class="number">0</span>’)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((c == ’&lt;’) &amp;&amp; (!quotation))</span><br><span class="line">        &#123;</span><br><span class="line">            quotation = TRUE;</span><br><span class="line">            ulimit--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> ((c == ’&gt;’) &amp;&amp; (quotation))</span><br><span class="line">    &#123;</span><br><span class="line">        quotation = FALSE;</span><br><span class="line">        ulimit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == ’(’ &amp;&amp; !quotation &amp;&amp; !rquote)</span><br><span class="line">    &#123;</span><br><span class="line">        rquote = TRUE;</span><br><span class="line">        <span class="comment">// FIX: insert ulimit--; here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == ’)’ &amp;&amp; !quotation &amp;&amp; rquote)</span><br><span class="line">    &#123;</span><br><span class="line">    rquote = FALSE;</span><br><span class="line">    ulimit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; ulimit)</span><br><span class="line">        *d++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rquote)</span><br><span class="line">        *d++ = ’)’;</span><br><span class="line">    <span class="keyword">if</span> (quotation)</span><br><span class="line">        *d++ = ’&gt;’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/9.png"></p>
<p>请注意， upperlimit是一个指针变量，而不是一个整数偏移量，因此，三要素中的数值实际上应该读作lbuf + num，其中num是来自缓冲区开始的相对偏移。我们表示这个值的方法是在自动机中只显示 num来表示这个值，为了简洁起见，在自动机中只显示num。循环中没有 在所研究的循环中没有第28行，在这个自动机中引入了一个有问题的 在这个自动机中，由于ulimit变量不再是 不再是有界的。这样就有可能给 ulimit的值大到足以触发对本地缓冲区的超边界写 在第35行对本地缓冲区的访问。我们可以正式确定一个 我们可以通过忽略转换，只保留 忽略过渡，只保留状态值。该 然后，自动机对应于以下公式P：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(ulim = lbuf + 15∧ quotation = F ∧ rquote = F) </span><br><span class="line">∨ (ulim = lbuf + 14 ∧ quotation = T ∧ rquote = F) </span><br><span class="line">∨ (ulim = lbuf + 14 ∧ quotation = F ∧ rquote = T ) </span><br><span class="line">∨ (ulim = lbuf + 13 ∧ quotation = T ∧ rquote = T )</span><br></pre></td></tr></table></figure>

<p>SMT求解器用来验证这种不变量的技术被称为归纳证明。简而言之，归纳证明包括两个步骤。</p>
<ol>
<li><p>证明该公式在基本情况下是成立的（在循环的入口点）：P(0)</p>
</li>
<li><p>证明如果该公式在循环的迭代n时成立，那么在循环的迭代n时也成立。证明如果该公式在循环的第n次迭代时成立，那么它在下一次迭代时也成立：∀n：P(n) ⇒ P(n + 1)</p>
</li>
</ol>
<p>P(0)表示不变式P在进入状态时成立，而P(n)表示P在第n次迭代时成立。这样的公式确实是归纳出来的，很容易被SMT求解器解决。我们现在给出这个证明的完整版本。</p>
<p>证明。该证明涉及对所有可能的循环状态和状态间的有效转换的分析。注意到这个公式在循环的入口处确实成立，因为入口状态（ulimit &#x3D; lbuf + 15 ∧ quotation &#x3D; F ∧ rquote &#x3D; F）与循环入口处的变量值完全对应。因此P(0)成立。</p>
<p>下一步包括以下内容：假设循环在迭代开始时处于不变量所描述的状态之一，循环是否保持在不变量所描述的状态中？有四种情况需要考虑（假设循环在四种状态中的一种开始），每种情况有四种子情况（假设我们从四种可用的过渡中选择一种，对应于循环的四个条件中的一个）。在实践中，并非所有状态下的过渡都是可用的。因此，证明会比展开16个不同的案例要小。</p>
<ol>
<li><p>假设循环迭代从状态（ulimit &#x3D; lbuf + 15 ∧ quotation &#x3D; F ∧ rquote &#x3D; F）开始。<br>  (a) 循环进入状态(ulimit &#x3D; lbuf + 14 ∧ quotation &#x3D; T ∧ rquote &#x3D; F) 如果它执行了第一个条件(第15-19行)<br>  (b) 如果循环执行第三个条件(第25-29行)，则进入状态(ulimit &#x3D; lbuf + 14 ∧ quotation &#x3D; F ∧ rquote &#x3D; T)<br>  (c) 没有其他条件可以从这种进入状态进入。</p>
</li>
<li><p>假设循环迭代从状态（ulimit &#x3D; lbuf + 14 ∧ quotation &#x3D; T ∧ rquote &#x3D; F）开始。<br>  (a) 如果循环执行第二个条件（第20-24行），则进入状态（ulimit &#x3D; lbuf + 15 ∧ quotation &#x3D; F ∧ rquote &#x3D; F）。<br>  (b) 没有其他条件可以从这种进入状态进入。</p>
</li>
<li><p>假设循环迭代从状态(ulimit &#x3D; lbuf + 14 ∧ quotation &#x3D; F ∧ rquote &#x3D; T)开始。<br>  (a) 如果循环执行第四个条件（第30-34行），则进入状态（ulimit &#x3D; lbuf + 15 ∧ quotation &#x3D; F ∧ rquote &#x3D; F）。<br>  (b) 如果循环执行第一个条件(第15-19行)，则进入状态(ulimit &#x3D; lbuf + 13 ∧ quote &#x3D; T ∧ rquote &#x3D; T)<br>  (c) 从这样的进入状态不能进入其他条件。</p>
</li>
<li><p>假设循环迭代从状态(ulimit &#x3D; lbuf + 13 ∧ quotation &#x3D; T ∧ rquote &#x3D; T)开始。<br>  (a) 如果循环执行第二个条件（第25-29行），则进入状态（ulimit &#x3D; lbuf + 14 ∧ quotation &#x3D; F ∧ rquote &#x3D; F）。<br>  (b) 没有其他条件可以从这种进入状态进入。</p>
</li>
</ol>
<p>因此，循环的所有可能状态都被该不变量正确地捕获。换句话说，∀n : P(n) ⇒ P(n + 1)</p>
<p>另一方面，当循环中没有第28行时，该公式被违反。这表明，当正确查询时，解算器能够区分正确的程序和无效的程序，即使是在微妙的条件下进行建模。然而，循环不变量必须由人工提供。据我们所知，目前还没有任何工具能够自动推断出这样的条件，可供公众使用。基于控制流分区的抽象解释技术已被证明对合成循环不变式很有用，但由于抽象解释为保持完全自动化而采用的过度近似，这种复杂不变式的合成似乎遥不可及。另一种推断简单循环不变式的策略是使用基于简单语法的不变式合成策略来生成候选者。这种方法已被用于执行运行时不变性综合，并在软件程序中发现基于见证执行的可能不变性。我们认为后一种方法在这个例子中不会带来预期的结果，因为在存在安全漏洞的情况下，不变量不会被尊重，因此不会通过执行要发现漏洞的程序跟踪来发现。</p>
<p>为了更好地说明推理问题，让我们尝试验证一个更抽象的公式，它是真实不变式的放松。这种更简单的公式是一个有趣的循环候选不变式，因为它包含更少的子公式，因此更有可能被自动生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ulim = lbuf + 15∧ quotation = F ∧ rquote = F) </span><br><span class="line">∨(ulim = lbuf + 14∧(quotation = T ∨rquote = T ))</span><br><span class="line">∨ (ulim = lbuf + 13 ∧ quotation = T ∧ rquote = T )</span><br></pre></td></tr></table></figure>

<p>这第二个公式对应于图3中的自动机。我们没有指出这第二个自动机的输入词汇，因为它并不对应于循环的具体表示，而是它的候选抽象。不幸的是，由于引入的假状态（T,T,14）不是循环的真实行为，这第二个不变性是无法证明的。当在这种虚假状态下启动循环，并执行循环的第二个条件代码（从图1的第20行到第24行），可以达到另一个虚假状态（F,T,15）。这样的状态是违反了不变式2。因此，不变式2在循环的每次迭代中都不成立。这个失败的例子显示了从不变式中抽象出信息而不失去健全性的困难。</p>
<p><img src="/img/10.png"></p>
<p>本节的案例研究很好地说明了SMT求解器在没有合适的约束生成引擎的情况下的局限性。只要这些不变量是由开发者提供的，就有可能验证代码不变量。然而，当没有来自开发者的输入时，对这种循环结构的自动分析是非常具有挑战性的，因为从一段代码中生成预期的契约并不是求解器的作用，而且现有的推理技术通常无法应对这种复杂的循环不变性。幸运的是，还存在许多其他的属性，这些属性的契约可以更容易被猜到。我们将在下一节中看到，这种限制并不针对漏洞发现的场景。</p>
<h1 id="漏洞利用生成中的SMT"><a href="#漏洞利用生成中的SMT" class="headerlink" title="漏洞利用生成中的SMT"></a>漏洞利用生成中的SMT</h1><p>自2008年以来，已经有许多论文试图开发依赖SMT求解器进行约束求解的自动漏洞生成（AEG）系统。这些早期的工作通常将漏洞定义为对程序的输入，通过利用某种内存损坏，导致程序计数器被劫持和执行攻击者控制的代码。就其核心而言，这些系统是对已成功应用于漏洞检测的输入生成技术的扩展。</p>
<p>虽然它们在合成简单漏洞的利用方面取得了有限的成功，但在放松操作系统安全措施的情况下，在它们适用于现实世界的问题之前，仍有很大的理论和实践差距需要弥补。在本节中，我们将解释这一差距是如何由问题领域的原始建模造成的，而不是基于SMT技术的限制。我们还将讨论一些比较成功的基于SMT的技术在开发中的应用问题。</p>
<h2 id="受限模型漏洞的产生"><a href="#受限模型漏洞的产生" class="headerlink" title="受限模型漏洞的产生"></a>受限模型漏洞的产生</h2><p>假设我们有一个标准的符号&#x2F;concolic执行环境，如S2E、BAP、TEMU、KLEE或其他地方描述的那些。在这些系统中，我们可以暂停符号执行，并为任何内存地址或寄存器标识符检索该位置的数据的路径条件。路径条件pc是一个逻辑公式，描述了从攻击者控制的源头引入到当前执行点之间对该数据进行的约束和操作。考虑下面的x86汇编代码样本，假设AL寄存器中的字节是在攻击者的控制之下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: add al, al</span><br><span class="line">1: sub al, 0x0f</span><br><span class="line">2: test al, al</span><br><span class="line">3: jz 5</span><br><span class="line">4: ...</span><br><span class="line">5: jmp 7</span><br><span class="line">6: ...</span><br></pre></td></tr></table></figure>

<p>如果我们将输入的字节表示为b0，并且在每次写入变量时创建一个新的变量bn，那么在地址6处，AL中的字节的路径条件是以下的连接条款</p>
<blockquote>
<p>b1 &#x3D; b0 + b0 ∧ b2 &#x3D; b1 − 15 ∧ b2 &#x3D; 0</p>
</blockquote>
<p>而在地址4处，路径条件是</p>
<blockquote>
<p>b1 &#x3D; b0 + b0 ∧ b2 &#x3D; b1 − 15 ∧ b2 6 &#x3D; 0</p>
</blockquote>
<p>然后，我们可以使用SMT求解器，通过添加约束条件和寻找满意的赋值来询问这些公式所代表的状态。例如，如果我们想在地址4检查值11是否可以在AL寄存器中，我们将创建一个公式。</p>
<blockquote>
<p>b1 &#x3D; b0 + b0 ∧ b2 &#x3D; b1 − 15 ∧ b2 6 &#x3D; 0 ∧ b2 &#x3D; 11</p>
</blockquote>
<p>然后SMT求解器将返回一个满意的赋值，如果存在的话，例如本例中的b0&#x3D;13。</p>
<p>实际上，系统所拥有的知识总和可以表示为一个从寄存器&#x2F;存储器标识符集合（i0, i1, …, in）到每个（pc0, pc1, …, pcn）的路径条件的映射K。K的类型为K : I → F。I是寄存器标识符集的联合，每个寄存器和子寄存器都有一个标识符，所有有效内存地址的标识符集，每个地址都有一个。F是固定大小的比特向量理论上的封闭无量纲公式集。</p>
<p>到目前为止，漏洞生成系统完全依赖于K，结合一套临时的漏洞模板，来扩展为输入生成所做的工作，以产生漏洞。我们将这种方法称为限制性模型漏洞生成。这种系统在处理非微不足道的漏洞方面缺乏成功，可以直接归因于所使用的执行环境的有限模型。在讨论这一点的原因之前，让我们首先定义一下我们所说的漏洞模板，然后看看两种典型的AEG方法。</p>
<h3 id="漏洞模版"><a href="#漏洞模版" class="headerlink" title="漏洞模版"></a>漏洞模版</h3><p>一组漏洞利用模板T是对利用漏洞的基本策略的算法描述的集合，这些策略符合一组标准，以便执行恶意代码。模板t∈T将把K作为输入，并产生一个SMT公式f。如果f中编码的模型准确地模拟了施加在程序输入和任何其他相关的程序状态和环境属性上的约束，那么f的一个满意的赋值将是对P的利用。一个AEG系统通常包括几个这样的模板，并根据从K中得到的信息和其他关于漏洞类型的信息在这些模板中进行选择。举例来说，如果AEG系统根据K检测到在执行ret指令时，ESP寄存器所指向的内存被攻击者控制，它可能会选择一个模板，表达以下约束：</p>
<blockquote>
<p>K(m) &#x3D; v0 ∧ K(m + 1) &#x3D; v1 ∧ K(m + 2) &#x3D; v2 ∧ K(m + 3) &#x3D; v3</p>
</blockquote>
<p>其中m是ESP寄存器中的值，(v0, v1, v2, v3)是0-255范围内的每个值，指定我们希望将控制流重定向到的地址。总的来说，到目前为止，在漏洞模板中编码的策略都是不成熟的。由于对程序状态进行精确约束的唯一信息来源是K，模板只能生成公式，对我们有路径条件的字节的可能值范围提出问题。复杂的利用策略，例如那些通常需要处理现代二进制加固和操作系统保护机制的策略，需要人们对比K所描述的更丰富的领域进行推理，例如，堆的状态以及它与用户输入的关系。同样地，对其他漏洞类别的利用需要进一步的抽象和模型，以引入AEG的符号&#x2F;concolic执行阶段。例如，自由使用问题既需要描述堆的状态，也需要涉及对象及其分配状态的更高层次的抽象。</p>
<h3 id="有限制性模型的AEG"><a href="#有限制性模型的AEG" class="headerlink" title="有限制性模型的AEG"></a>有限制性模型的AEG</h3><p>有两种类似的机制被用于AEG，它们都可以被归类为限制性模型漏洞生成。在第一个机制中[20]，我们从一个程序P和一个我们知道是坏的输入I开始。例如，I可能是由一个模糊器产生的，并导致P崩溃。在这种方法下，我们在一个简洁的执行环境中执行P(I)，直到正常执行时发生崩溃。在这一点上，K是可用的，我们也有关于崩溃原因的信息，例如，我们知道它是否是由于试图执行、读或写无效的内存。</p>
<p>如上所述，这样的系统还将包括一个漏洞模板库T。利用K和对崩溃原因的了解，可以选择一个或多个模板并生成一组公式。</p>
<p>第二种方法是将漏洞检查过程与AEG[1]相结合。在这种方法下，一个符号&#x2F;concolic执行环境被用来在符号输入数据上执行程序。一个安全谓词φ在特定的程序点上被调用，以检查是否有潜在的不安全操作发生。例如，在调用memcpy时，安全谓词可能会检查大小参数是否有足够的限制以防止目的地缓冲区的溢出。一旦安全谓词返回false，这种方法就可以再次访问K，但有可能检查取决于K元素值的多种可能的利用情况。</p>
<p>例如，在易受攻击的memcpy上，假设目标缓冲区的大小为n字节，但大小参数可以是m字节，m&gt;n，那么有m-n个可能的长度会违反安全属性。在第一种方法下，一个坏的输入提供了一个单一的违反安全属性的情况。在这种情况下，每个不同的输入长度n &lt; l ≤ m导致不同数量的数据被破坏。因此，对于每个l的值，可以使用K和T生成一组公式。根据l的值，被破坏的数据可能会导致不同的利用可能性，例如，破坏4个字节可能会导致控制一个作为写的目的地的指针，而破坏12个可能会导致控制一个函数指针。因此，第二种方法可以使用更多的模板产生更多的候选漏洞。但需要注意的是，这些候选者中的每一个都是用K和T生成的，因此如前所述是有限的。</p>
<p>从概念上讲，这两种方法都与基于符号&#x2F;concolic执行的漏洞检测系统所需的技术相当接近。因此，我们可以问，为什么这种方法在现实世界的漏洞检测中是成功的，而在现实世界的漏洞生成中是失败的？通过考虑推理中使用的模型对被建模的问题的准确性，可以找到答案。成功的漏洞检测系统已经发现了大量由于程序中不安全的运算而产生的漏洞。在这种情况下，准确决定一个指令序列是否不安全所需的信息包含在输出字节的路径条件中。在这种情况下，模型K相当接近于决定问题领域的问题的理想模型。</p>
<p>如果我们忽略了二进制加固，如堆栈金丝雀，以及操作系统的安全措施，如地址空间布局随机化（ASLR）、内存区域的无执行（NX）权限和更安全的内存分配器，那么对于某些漏洞类别，使用模型K，AEG也是一个可行的问题。在这种环境下，影响攻击成败的主要因素是执行指令的操作和约束。由于这些因素是由K来模拟的，那么模板就有可能创建一个SMT公式，准确地描述一个工作漏洞的要求。</p>
<p>一些AEG系统说明了某些保护机制，例如没有NX的有限ASLR[20]和有有限ASLR的NX[32]，同时支持有限的漏洞类型，例如没有功能堆栈加固的堆栈式溢出。这些系统对它们所能处理的问题所施加的限制，有效地将被利用的程序环境的状态减少到由K充分精确地建模的状态。</p>
<p>一旦开始考虑现代Linux和Windows操作系统中正确实施的保护机制，K作为一个模型的准确性就会迅速恶化。一旦我们开始考虑利用需要操纵环境因素（如堆布局）的漏洞，它也会恶化。在这些情况下，一个有用的模型必须考虑到用户输入对内存布局的影响。</p>
<h3 id="AEG的功能"><a href="#AEG的功能" class="headerlink" title="AEG的功能"></a>AEG的功能</h3><p>为了成为一个实用的解决方案，在AEG方面还有很多工作要做。以SMT为基础的方法已经显示出了前景，但是约束条件的生成阶段仍然限制了这些系统对现代软件和操作系统的适用性。特别是程序及其环境的模型必须得到改进。同时，值得考虑的是对模板驱动的AEG方法所做的改变，以适应更多应用和漏洞特定的开发技术的趋势。</p>
<p>缩小系统模型和系统之间的差距可以通过两种方式进行。第一种是迄今为止AEG所采取的方法，即降低系统的复杂性，直到模型足够精确。第二种是提高模型的复杂程度，使其包含更多的系统信息。</p>
<p>在早期的AEG工作中，采取前一种方法的原因很直接；扩展以前的符号&#x2F;concolic执行工作以产生模型K是相对便宜的。显然，这个模型是对现代漏洞生成必须考虑的状态的不现实的抽象。如果我们考虑到缺乏关于程序输入和堆内存布局之间关系的任何信息，就可以看出这一点。没有这样的信息，我们就不能生成约束条件，对于这些约束条件，一个满意的赋值可以准确地操纵堆。因此，我们无法对任何可能受到堆随机化影响的漏洞进行可靠的AEG。这包括堆溢出，但也包括自由使用后的漏洞，这是网络浏览器中最多的安全漏洞形式。</p>
<p>在考虑AEG的未来发展方向时，重要的是要看一下手动创建漏洞的最新发展。一段时间以来，利用分配器和保护机制的明显缺陷的通用开发技术的时代已经接近尾声。虽然总会有例外，但利用应用程序和特定漏洞的方法来避开保护机制，而不是试图击败它们，这是更常见的。例如，在堆溢出的情况下，如果能对以后被调用的同一块中的指针值进行受控覆盖，比试图破坏堆元数据更有可能成功。</p>
<p>现代漏洞也更有可能利用信息泄露攻击，这是一个迄今为止在AEG方面没有得到关注的话题。虽然许多人认为信息泄露是由不同的漏洞类型造成的，但某些漏洞是很常见的，比如 “无用后”、”双重无用 “等，既可以利用信息泄露也可以利用代码执行。</p>
<p>这两个问题结合在一起，使人怀疑模板驱动的AEG是否有足够的通用性以发挥作用。我们认为，一旦有了足够精确的模型，允许用户根据他们对开发、应用和漏洞的了解，结合更有限的一般和特定应用的模板，来驱动约束条件的产生，将是更有用的。</p>
<h2 id="自动创建payload"><a href="#自动创建payload" class="headerlink" title="自动创建payload"></a>自动创建payload</h2><p>虽然AEG系统已经试图将开发的控制流劫持部分自动化，但也有关于基于SMT的系统应用于生成ROP payload的研究[29, 34, 16, 32]。这些系统的开发是为了将漏洞开发者从繁琐的过程中解放出来，即在一个大型二进制文件中可能发现的数十万个候选小工具。</p>
<p>正如介绍中提到的，所采取的方法分为两类。那些试图一次证明单个小工具与我们希望进行的某些计算的模型之间的等价性的方法[34]，以及后来试图提供一个完整的编译器的系统，该编译器可以依次组装多个小工具以实现这种计算[16, 32]。</p>
<p>在前一种方法中，我们首先收集二进制中每一个有效的指令序列，这些指令的结尾可以成功地将执行转移到序列中的下一个小工具，例如，如果小工具的地址是在ESP所指向的位置提供的，那么就是一个ret指令。系统将这些候选小工具和我们要求执行的计算规格作为输入，例如，ESP &lt;- EAX + 8，这表明我们正在寻找一个小工具，将存储在EAX寄存器中的值加上8放到ESP寄存器中。</p>
<p>首先，系统将创建一个计算规范的SMT表示ssmt。换句话说，它将把规范转换成一个SMT公式。然后，系统将对候选小工具集进行一些启发式的，但合理的削减，例如，消除任何既不读EAX也不写ESP的小工具。在这一点上，系统将遍历剩余的候选小工具C，并为每个小工具g∈C创建表达语义g的一组公式的连接。如果该公式是有效的<br>这意味着在对g和ssmt中的变量的所有解释下，它们的语义是等同的。这告诉我们，这个小工具可以用来表达我们所需要的计算。如果公式是可满足的，但不是有效的，这意味着这个小工具在某些解释下可能有效，但在其他解释下可能无效。这将不是一个 一个可靠的利用中的组件的理想属性。</p>
<p>已经开发并成功地应用于这个问题，这些系统将SMT技术用于不同的目的。在[16]中，一个SMT求解器被用来推理含有分支的小工具。例如，如果小工具包含一个可能导致崩溃的指令序列的分支，求解器将被用来检查在小工具的语义下，是否有可能从未采取过分支。在[32]中，一个SMT求解器被用来寻找符合计算规范要求的小工具的排列。</p>
<p>单个小工具和小工具编译器的方法都成功地减轻了ROP有效载荷创建过程中的一定程度的人工努力。在这两种方法中，我们可以看到存在于整个SMT技术成功整合的模式–最大限度地减少必须向求解器提出的查询次数，通过使用计算成本较低的算法减少问题空间，并确保生成的约束条件是被推理的问题的足够准确的模型。</p>
<h1 id="保护分析中的SMT"><a href="#保护分析中的SMT" class="headerlink" title="保护分析中的SMT"></a>保护分析中的SMT</h1><p>软件保护分析在处理恶意软件方面至关重要，因为大多数样本采用了某种包装或混淆技术，以阻挠分析。在保护数字资产免受盗版和知识产权盗窃的过程中，它也是一个备受关注的经济领域。我们介绍了SMT求解器在这些问题上实际应用的几个领域。</p>
<h2 id="用于验证去模糊化结果的等价检查"><a href="#用于验证去模糊化结果的等价检查" class="headerlink" title="用于验证去模糊化结果的等价检查"></a>用于验证去模糊化结果的等价检查</h2><p>虚拟化混淆器[31]是一类特别复杂的软件保护工具，通常被恶意软件所滥用。这些工具的工作原理是将要保护的程序的x86机器语言的一部分转换为随机生成的语言，然后在运行时在解释器中执行，解释器本身也是随机生成和混淆的。这些区域的原始X86机器代码随后被覆盖。代码在二进制文件中生成，这样在运行时，当程序执行受保护的代码时，寄存器状态被保存到某个位置（例如，到堆栈），解释器执行，寄存器状态被重新加载，然后程序的未受保护部分正常执行。最终的结果是，恶意软件分析师必须拥有一个工具来反转翻译，或在解释器内运行时对代码进行反向工程（而不是以他或她更习惯的形式，即X86代码）。</p>
<p>这样的工具使逆向工程师的工作变得困难，而且对保护作者来说，它们的构造也相当复杂。翻译必须精确地捕捉所考虑的指令的语义，否则，虚拟化的程序有可能产生与原始程序不同的行为，而这些行为–通过明确的设计目标–对开发者来说是很难诊断的。鉴于这种复杂性，这些工具可能会有不恰当的翻译形式的错误，这并不是一个令人惊讶的概念。同样地，如果分析者要构建一个反转工具来反混淆一个虚拟化混淆器，这样的工具的复杂性很容易导致不适当的反混淆形式的bug。</p>
<p>等价检查是一种著名的技术，用于验证两段代码的等价性。最简单的情况是当代码片段是直线型的（即无分支）。作为一个例子，考虑C程序x0 &#x3D; y + y;和x1 &#x3D; y &lt;&lt; 1;。这两个程序在逻辑上都是对变量y翻倍并将结果存储在其他变量中的概念进行编码（因为左移1相当于乘以2）。为了确定这些序列是否产生相等的结果，我们把它们编码为SMT公式，然后查询决策程序的条件x0 6 &#x3D; x1。如果这个公式是可满足的，SMT求解器将返回一个反例，即两个序列不同的y值。如果这个公式是不可满足的，这就是一个证明（假设求解器是健全的），即在相同的输入下，两个序列总是产生相同的输出。</p>
<p>为了将这一程序应用于两条无分支的x86指令序列，我们将这两个序列转换为我们的中间表示法，然后将这两个序列置于单次静态赋值（SSA [13]）的形式中，将IR的SSA版本转换为SMT公式，并询问决策程序的输出变量（即标志、寄存器和内存）是否可以不同（即，eaxseq1 6 &#x3D; eaxseq2 ∨ ebxseq1 6 &#x3D; ebxseq2 …）。为了以这种方式比较内存的内容，解算器必须支持扩展数组的理论（幸运的是许多现代解算器都支持）。</p>
<p>SMT支持的等价检查为确保无分支序列上的去混淆程序的正确性提供了一个强大的原始方法。我们只需生成一些属于虚拟化混淆器范围内的无分支程序，对其进行混淆，然后对其进行解混淆，并使用等价检查将生成的代码与原始代码进行比较。</p>
<p>应用这个程序有助于发现TheMida CISC虚拟机[37]中潜在的不正确的翻译，此前已经为这种保护构建了一个去混淆程序。某些指令的虚拟化，如ror和inc，没有考虑到这些指令的一些微妙之处。在ror和类似指令的情况下，英特尔手册规定，如果shiftand为零，这些指令不会修改标志。因此，在执行这些指令之前对标志的不适当维护可能会导致标志在混淆和去混淆的版本中取不同的值。同样，”inc “并没有修改携带标志，所以在指令执行前由混淆器引起的对该标志的任何修改都会导致不正确的机器状态。</p>
<p>图4说明了翻译中潜在的不正确性的一个更微妙的例子。这个（去混淆的）指令序列从esi寄存器指向的内存位置加载一个地址（以加密的形式存储），在接下来的四条指令中解密该地址，然后从该地址加载一个字节并将其推入堆栈。由于破译过程是可逆的，这个代码片段对可能加载字节的地址范围没有任何限制。因此，该地址很可能指向堆栈，低于当前堆栈指针的位置。由于混淆器向堆栈引入了许多虚假的写入，在去混淆的世界中加载的值可能与混淆的世界中的值不同。这种翻译错误在现实世界中不太可能导致运行时错误，但它显示了SMT求解器对等价检查问题的详尽能力。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1: lodsd dword ptr ds:[esi]</span><br><span class="line">2: sub eax, ebx</span><br><span class="line">3: xor eax, 7134B21Ah</span><br><span class="line">4: add eax, 2564E385h</span><br><span class="line">5: xor ebx, eax</span><br><span class="line">6: movzx ax, byte ptr ds:[eax]</span><br><span class="line">7: push ax</span><br></pre></td></tr></table></figure>

<h2 id="基于SMT的半自动密码分析的输入工艺"><a href="#基于SMT的半自动密码分析的输入工艺" class="headerlink" title="基于SMT的半自动密码分析的输入工艺"></a>基于SMT的半自动密码分析的输入工艺</h2><p>当涉及到构建许可系统时，最佳实践决定了只有经过适当审查的可信加密算法的实现才能被用作安全设计的密码系统的一部分。(即使如此，这可能不足以防止某些类型的攻击，例如那些攻击者能够替换二进制中的私钥或以其他方式修补程序的逻辑。作为软件保护中永无止境的猫捉老鼠游戏的一部分，像[39]这样的技术可以用来混淆加密密钥，而像[36]这样的技术表明，这些技术不一定是无懈可击的）。不幸的是，许多保护作者仍然没有听从这个建议，导致点对点网络上有大量的破解软件。</p>
<p>SMT求解器可以作为手动建模许可方案的媒介。[14]重点讨论了一个 图5中部分描述了一种方案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1: again:</span><br><span class="line">2: lodsb</span><br><span class="line">3: sub al, bl</span><br><span class="line">4: xor al, dl</span><br><span class="line">5: stosb</span><br><span class="line">6: rol edx, 1</span><br><span class="line">7: rol ebx, 1</span><br><span class="line">8: loop again</span><br></pre></td></tr></table></figure>

<p>首先，作者从代数的角度对保护进行了人工加密分析，并构建了一个高效的密钥发生器。接下来，作者展示了如何用SAT问题的实例来手动建立方案的模型。由于现代SMT求解器归属于SAT求解器，该方案显然可以用比特向量理论中的操作来手动建模，其方式比低级的比特手动CNF编码更简洁自然。例如，一个乘法运算符可以在许多求解器中被模拟成一个项，而用对单个比特的操作来模拟这样的事情（如在SAT实例中）会产生复杂的电路。图5中所示的循环的一次迭代可以在SMT中手动建模，具体如下。</p>
<p>首先，作者从代数的角度对保护进行了手工加密分析，并构建了一个高效的密钥发生器。接下来，作者展示了如何用SAT问题的实例对该方案进行手动建模。由于现代SMT求解器归属于SAT求解器，该方案显然可以用比特向量理论中的操作来手动建模，其方式比低级的比特手动CNF编码更简洁自然。例如，一个乘法运算符可以在许多求解器中被原生地建模为一个项，而用对单个比特的操作来建模（如在SAT实例中）会产生复杂的电路。图5中所示的循环的一个迭代（尤其是迭代i）可以在SMT中手动建模如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">al0,i = activation code[i] ∧ al1,i = al0,i − ebxi</span><br><span class="line">[7 : 0]</span><br><span class="line">∧ al2,i = al1,i ⊕ edxi</span><br><span class="line">[7 : 0]</span><br><span class="line">∧ output[i] = al2,i</span><br><span class="line">∧ edxi+1 = rotate lef t(edxi, 1)</span><br><span class="line">∧ ebxi+1 = rotate lef t(ebxi, 1)</span><br></pre></td></tr></table></figure>

<p>在这个公式中，激活代码对应于esi寄存器所指向的内存区域，是串行算法的输入，输出对应于edi寄存器所指向的内存区域，而rotate lef t是许多SMT求解器中用于执行向左旋转的内置函数。</p>
<p>在其他问题领域用于编程语言理论中更常规的任务的相同技术，如前面讨论的那些，即漏洞发现和测试案例&#x2F;漏洞生成，也可以被重新利用，以便半自动地解决像这样的问题。我们采用了Pandemic二进制程序分析框架[30]来自动（静态地）生成算法运行的执行轨迹，其中用户的输入被视为自由变量。然后，我们手动构建了输出必须满足的后置条件，然后将结果反馈给SMT求解器。解算器得出的输入正确地打破了这个方案。由于篇幅的考虑，我们不得不让感兴趣的读者参考[30]，以了解问题的更多细节、Pandemic的系统结构和解决方案。</p>
<p>如果分析者愿意投入时间手动模拟串行算法的执行所需的状态，可以纯粹静态地攻击这些问题，也可以采用协程方式（可以实现更大的自动化）。当分析员希望调查他或她可能不知道如何触发的某段代码的属性时，静态解决方案可能是首选；静态调查可以告知分析员这样做是否值得（即，这部分代码是否表现出一些漏洞；如果不是这样，那么驱动执行到该位置的更广泛的问题将是没有结果的）。</p>
<p>这个特定的问题实例有一个很好的特性，即算法所采取的路径不依赖于用户的输入。具体来说，该算法由一个循环组成，在将输出与一个固定值进行比较之前，该循环会执行固定数量的迭代。因此，这个问题比在路径依赖输入的情况下更容易解决，例如，如果多个检查导致失败的情况，或者如果输入的长度不受限制，而算法在其上全部迭代（这种情况有可能通过使用循环不变量，或许是自动合成的不变量来缓解）。然而，我们强调，串行算法并没有什么特别之处，使它们处于一般输入起草问题的严格限制类中：任何类型的代码（包括混淆的代码），具有不受限制的编程语言结构，都可能被用来实现串行检查–事实上，由于硬加密操作的普遍存在，这些限制甚至可能比普通情况更难。因此，这一追求的进展是与二进制程序分析和验证&#x2F;SMT求解器的一般进展联系在一起的。然而，这些早期结果是令人鼓舞的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SMT解算器正在成为安全工程师工具箱中不可或缺的一部分。我们介绍了SMT求解器在静态分析的漏洞发现、漏洞生成（输入工艺的专业化）和复制保护分析中的三种应用。在这三种应用中，求解器在协助分析员决定所建议的解决方案在其各自的问题空间中是否有效方面做了出色的工作。然而，求解器并不适合生成特定领域的问题描述，因为初步的约束生成步骤必须在求解器之外进行。我们期望专门的约束推理助手在未来会有所改进，并帮助生成计算机安全领域非琐碎问题的正式问题定义。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li>
        
          <li><a href="/books/">Books</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞利用生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BF%9D%E6%8A%A4%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">复制保护分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">3.</span> <span class="toc-text">漏洞检测中的SMT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用生成中的SMT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E6%A8%A1%E5%9E%8B%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">4.1.</span> <span class="toc-text">受限模型漏洞的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E7%89%88"><span class="toc-number">4.1.1.</span> <span class="toc-text">漏洞模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%88%B6%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84AEG"><span class="toc-number">4.1.2.</span> <span class="toc-text">有限制性模型的AEG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AEG%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.3.</span> <span class="toc-text">AEG的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BApayload"><span class="toc-number">4.2.</span> <span class="toc-text">自动创建payload</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84SMT"><span class="toc-number">5.</span> <span class="toc-text">保护分析中的SMT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E5%8E%BB%E6%A8%A1%E7%B3%8A%E5%8C%96%E7%BB%93%E6%9E%9C%E7%9A%84%E7%AD%89%E4%BB%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">5.1.</span> <span class="toc-text">用于验证去模糊化结果的等价检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESMT%E7%9A%84%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E7%9A%84%E8%BE%93%E5%85%A5%E5%B7%A5%E8%89%BA"><span class="toc-number">5.2.</span> <span class="toc-text">基于SMT的半自动密码分析的输入工艺</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&text=[译文]用于软件安全的SMT解算器"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&is_video=false&description=[译文]用于软件安全的SMT解算器"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]用于软件安全的SMT解算器&body=Check out this article: http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&title=[译文]用于软件安全的SMT解算器"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&name=[译文]用于软件安全的SMT解算器&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2023/01/12/SMT_Solvers_for_Software_Security/&t=[译文]用于软件安全的SMT解算器"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2023
    TUGOhost
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     --><!--
       --><li><a href="/books/">Books</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
