<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="[译文]VMProtect2-虚拟机架构的详细分析 https:&#x2F;&#x2F;back.engineering&#x2F;17&#x2F;05&#x2F;2021&#x2F;#deadstore-obfuscation-example If there is any infringement, please send an email to tu9oh0st@duck.com and I will promptly remove the arti">
<meta property="og:type" content="article">
<meta property="og:title" content="[译文]VMProtect2-虚拟机架构的详细分析">
<meta property="og:url" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/index.html">
<meta property="og:site_name" content="TUGOhost">
<meta property="og:description" content="[译文]VMProtect2-虚拟机架构的详细分析 https:&#x2F;&#x2F;back.engineering&#x2F;17&#x2F;05&#x2F;2021&#x2F;#deadstore-obfuscation-example If there is any infringement, please send an email to tu9oh0st@duck.com and I will promptly remove the arti">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/1.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/22.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/2.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/3.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/4.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/5.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/6.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/7.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/8.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/9.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/10.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/11.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/12.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/13.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/14.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/15.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/16.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/17.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/18.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/19.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/20.png">
<meta property="og:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/21.png">
<meta property="article:published_time" content="2022-12-06T02:28:25.000Z">
<meta property="article:modified_time" content="2023-10-15T12:05:49.064Z">
<meta property="article:author" content="TUGOhost">
<meta property="article:tag" content="逆向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>[译文]VMProtect2-虚拟机架构的详细分析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     --><!--
       --><li><a href="/books/">Books</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/01/01/MIUI_PrivacyManager/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/10/07/Web_3%E5%AD%A6%E4%B9%A0%E6%95%B4%E5%90%88/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&text=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&is_video=false&description=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]VMProtect2-虚拟机架构的详细分析&body=Check out this article: http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&name=[译文]VMProtect2-虚拟机架构的详细分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&t=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%91%E6%96%87-VMProtect2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">[译文]VMProtect2-虚拟机架构的详细分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Credit-Links-to-Exiiting-Work"><span class="toc-number">2.</span> <span class="toc-text">Credit - Links to Exiiting Work</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E8%A8%80-%E6%84%8F%E5%9B%BE%E5%92%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">序言 - 意图和目的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">3.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">意图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86-Deadstore%EF%BC%8C%E4%B8%8D%E9%80%8F%E6%98%8E%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">6.</span> <span class="toc-text">混淆-Deadstore，不透明的分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E5%88%86%E6%94%AF%E6%B7%B7%E6%B7%86%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">不透明分支混淆实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deadstore-%E6%B7%B7%E6%B7%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">Deadstore 混淆示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-VMProtect-2-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">概述 - VMProtect 2 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%BC%8F%E8%A7%A3%E5%AF%86"><span class="toc-number">7.1.</span> <span class="toc-text">滚动式解密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">本地寄存器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8%E2%80%93%E6%9C%89%E7%89%B9%E5%AE%9A%E7%94%A8%E9%80%94%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">非易失性寄存器–有特定用途的寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E5%A4%B1%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8-%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">易失性寄存器 - 临时寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-entry-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">vm_entry - 虚拟机的入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calc-jmp-%E8%A7%A3%E5%AF%86Vm-Handler%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">calc_jmp - 解密Vm Handler的索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-exit-%E7%A6%BB%E5%BC%80%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.5.</span> <span class="toc-text">vm_exit - 离开虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-vsp-%E9%87%8D%E5%AE%9A%E4%BD%8Dscratch%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.6.</span> <span class="toc-text">check_vsp - 重定位scratch寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4-%E6%93%8D%E4%BD%9C%E7%A0%81%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E3%80%81%E8%A7%84%E6%A0%BC"><span class="toc-number">7.7.</span> <span class="toc-text">虚拟指令 - 操作码、操作数、规格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A7%A3%E5%AF%86-Transformations"><span class="toc-number">7.7.1.</span> <span class="toc-text">操作符解密 - Transformations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-Handlers-%E8%A7%84%E6%A0%BC"><span class="toc-number">7.8.</span> <span class="toc-text">VM Handlers - 规格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LCONST-%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%B8%B8%E9%87%8F%E5%80%BC"><span class="toc-number">7.8.1.</span> <span class="toc-text">LCONST - 在堆栈中加载常量值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTQ-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0QWORD"><span class="toc-number">7.8.1.1.</span> <span class="toc-text">LCONSTQ - 加载常数QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCDQE-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0DWORD%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E5%88%B0%E4%B8%80%E4%B8%AAQWORD"><span class="toc-number">7.8.1.2.</span> <span class="toc-text">LCONSTCDQE - 加载常数DWORD符号扩展到一个QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCBW-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0%E5%AD%97%E8%8A%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97"><span class="toc-number">7.8.1.3.</span> <span class="toc-text">LCONSTCBW - 加载常数字节转换为字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCWDE-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BADWORD"><span class="toc-number">7.8.1.4.</span> <span class="toc-text">LCONSTCWDE - 加载常数字转换为DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTDW-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0DWORD"><span class="toc-number">7.8.1.5.</span> <span class="toc-text">LCONSTDW - 加载常数DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LREG-%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%AD%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC"><span class="toc-number">7.8.2.</span> <span class="toc-text">LREG - 在堆栈中加载Scratch寄存器的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LREGQ-%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8QWORD"><span class="toc-number">7.8.2.1.</span> <span class="toc-text">LREGQ - 加载Scratch寄存器QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LREGDW-%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8DWORD"><span class="toc-number">7.8.2.2.</span> <span class="toc-text">LREGDW - 加载Scratch寄存器DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SREG-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC"><span class="toc-number">7.8.3.</span> <span class="toc-text">SREG - 设置Scratch寄存器值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGQ-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCQWORD"><span class="toc-number">7.8.3.1.</span> <span class="toc-text">SREGQ - 设置Scratch寄存器值QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGDW-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCDWORD"><span class="toc-number">7.8.3.2.</span> <span class="toc-text">SREGDW - 设置Scratch寄存器值DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGW-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCWORD"><span class="toc-number">7.8.3.3.</span> <span class="toc-text">SREGW - 设置Scratch寄存器值WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGB-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%80%BC"><span class="toc-number">7.8.3.4.</span> <span class="toc-text">SREGB - 设置Scratch寄存器的字节值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD-%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.</span> <span class="toc-text">ADD - 两个值相加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDQ-%E4%B8%A4%E4%B8%AAQWORD%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.1.</span> <span class="toc-text">ADDQ - 两个QWORD值相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDW-%E4%B8%A4%E4%B8%AAWORDS%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.2.</span> <span class="toc-text">ADDW - 两个WORDS值相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDB-%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.3.</span> <span class="toc-text">ADDB - 两个字节的值相加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MUL-%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="toc-number">7.8.5.</span> <span class="toc-text">MUL - 无符号乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MULQ-QWORD%E7%9A%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="toc-number">7.8.5.1.</span> <span class="toc-text">MULQ - QWORD的无符号乘法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIV-%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">7.8.6.</span> <span class="toc-text">DIV - 无符号除法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DIVQ-QWORD%E7%9A%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">7.8.6.1.</span> <span class="toc-text">DIVQ - QWORD的无符号除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#READ-%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98"><span class="toc-number">7.8.7.</span> <span class="toc-text">READ - 读取内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#READQ-%E8%AF%BB%E5%8F%96QWORD"><span class="toc-number">7.8.7.1.</span> <span class="toc-text">READQ - 读取QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READDW-%E8%AF%BB%E5%8F%96DWORD"><span class="toc-number">7.8.7.2.</span> <span class="toc-text">READDW - 读取DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READW-%E8%AF%BB%E5%8F%96%E5%AD%97"><span class="toc-number">7.8.7.3.</span> <span class="toc-text">READW - 读取字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WRITE-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-number">7.8.8.</span> <span class="toc-text">WRITE - 写入内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEQ-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98QWORD"><span class="toc-number">7.8.8.1.</span> <span class="toc-text">WRITEQ - 写入内存QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEDW-%E5%86%99%E5%85%A5DWORD"><span class="toc-number">7.8.8.2.</span> <span class="toc-text">WRITEDW - 写入DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEW-%E5%86%99%E5%85%A5WORD"><span class="toc-number">7.8.8.3.</span> <span class="toc-text">WRITEW - 写入WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEB-%E5%86%99%E5%85%A5%E5%AD%97%E8%8A%82"><span class="toc-number">7.8.8.4.</span> <span class="toc-text">WRITEB - 写入字节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHL-%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.</span> <span class="toc-text">SHL - 左移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLCBW-%E5%B7%A6%E7%A7%BB%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%9C%E4%B8%BAWORD"><span class="toc-number">7.8.9.1.</span> <span class="toc-text">SHLCBW - 左移转换结果为WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLW-WORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.2.</span> <span class="toc-text">SHLW - WORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLDW-DWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.3.</span> <span class="toc-text">SHLDW - DWORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLQ-QWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.4.</span> <span class="toc-text">SHLQ - QWORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLD-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.5.</span> <span class="toc-text">SHLD - 双精度左移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SHLDQ-%E5%90%91%E5%B7%A6%E7%A7%BB%E5%8A%A8%E5%8F%8C%E7%B2%BE%E5%BA%A6QWORD"><span class="toc-number">7.8.9.5.1.</span> <span class="toc-text">SHLDQ - 向左移动双精度QWORD</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLDDW-%E5%8F%8C%E7%B2%BE%E5%BA%A6DWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.6.</span> <span class="toc-text">SHLDDW - 双精度DWORD左移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHR-%E5%8F%B3%E7%A7%BB"><span class="toc-number">7.8.10.</span> <span class="toc-text">SHR - 右移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRQ-%E5%8F%B3%E7%A7%BBQWORD"><span class="toc-number">7.8.10.1.</span> <span class="toc-text">SHRQ - 右移QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRD-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BB"><span class="toc-number">7.8.10.2.</span> <span class="toc-text">SHRD - 双精度右移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRDQ-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BBQWORD"><span class="toc-number">7.8.10.3.</span> <span class="toc-text">SHRDQ - 双精度右移QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRDDW-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BBDWORD"><span class="toc-number">7.8.10.4.</span> <span class="toc-text">SHRDDW - 双精度右移DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAND-Not-Then-And"><span class="toc-number">7.8.11.</span> <span class="toc-text">NAND - Not Then And</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NANDW-%E4%B8%8D%E6%98%AF%E7%84%B6%E5%90%8E%E5%92%8CWORD%E7%9A%84"><span class="toc-number">7.8.11.1.</span> <span class="toc-text">NANDW - 不是然后和WORD的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READCR3-%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A83"><span class="toc-number">7.8.11.2.</span> <span class="toc-text">READCR3 - 读取控制寄存器3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITECR3-%E5%86%99%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A83"><span class="toc-number">7.8.11.3.</span> <span class="toc-text">WRITECR3 - 写控制寄存器3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PUSHVSP-Push%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">7.8.12.</span> <span class="toc-text">PUSHVSP - Push虚拟堆栈指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSHVSPQ-Push%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88QWORD"><span class="toc-number">7.8.12.1.</span> <span class="toc-text">PUSHVSPQ - Push虚拟堆栈指针QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSHVSPDW-%E6%8E%A8%E9%80%81%E8%99%9A%E6%8B%9F%E6%A0%88%E6%8C%87%E9%92%88DWORD"><span class="toc-number">7.8.12.2.</span> <span class="toc-text">PUSHVSPDW - 推送虚拟栈指针DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSVSPW-%E6%8E%A8%E9%80%81%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E7%9A%84WORD%E5%80%BC"><span class="toc-number">7.8.12.3.</span> <span class="toc-text">PUSVSPW - 推送虚拟堆栈指针的WORD值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVSP-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">7.8.13.</span> <span class="toc-text">LVSP - 加载虚拟堆栈指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LVSPW-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E5%AD%97"><span class="toc-number">7.8.13.1.</span> <span class="toc-text">LVSPW - 加载虚拟堆栈指针字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LVSPDW-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88DWORD"><span class="toc-number">7.8.13.2.</span> <span class="toc-text">LVSPDW - 加载虚拟堆栈指针DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRFLAGS-%E5%8A%A0%E8%BD%BDRFLAGS"><span class="toc-number">7.8.13.3.</span> <span class="toc-text">LRFLAGS - 加载RFLAGS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMP-%E8%99%9A%E6%8B%9F%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">7.8.14.</span> <span class="toc-text">JMP - 虚拟跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALL-%E8%99%9A%E6%8B%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">7.8.15.</span> <span class="toc-text">CALL - 虚拟调用指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AD%BE%E5%90%8D-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">重要的虚拟机签名 - 静态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%A1%A8"><span class="toc-number">8.1.</span> <span class="toc-text">定位虚拟机处理程序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%A1%A8%E6%9D%A1%E7%9B%AE%E8%A7%A3%E5%AF%86"><span class="toc-number">8.2.</span> <span class="toc-text">定位虚拟机处理程序表条目解密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BD%AC%E6%8D%A2%E2%80%93%E6%A8%A1%E6%9D%BF%E5%8C%96%E7%9A%84Lambdas%E5%92%8CMaps"><span class="toc-number">8.3.</span> <span class="toc-text">处理转换–模板化的Lambdas和Maps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E8%BD%AC%E6%8D%A2-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%BB%A7%E7%BB%AD"><span class="toc-number">8.3.1.</span> <span class="toc-text">提取转换 - 静态分析继续</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E5%9B%B0%E5%A2%83-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="toc-number">8.4.</span> <span class="toc-text">静态分析的困境 - 静态分析的结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vmtracer-%E8%BF%BD%E8%B8%AA%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">8.4.1.</span> <span class="toc-text">vmtracer - 追踪虚拟指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmprofile-cli-%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B7%9F%E8%B8%AA%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">8.4.2.</span> <span class="toc-text">vmprofile-cli - 使用运行时跟踪的静态分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF-vmprofiler-qt"><span class="toc-number">9.</span> <span class="toc-text">显示跟踪信息 - vmprofiler-qt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">10.</span> <span class="toc-text">虚拟机的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E8%B7%9F%E8%B8%AA"><span class="toc-number">11.</span> <span class="toc-text">Demo - 创建和检查一个虚拟跟踪</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">12.</span> <span class="toc-text">改变虚拟指令的结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E8%BD%AC%E6%8D%A2"><span class="toc-number">13.</span> <span class="toc-text">编码虚拟指令 - 逆向转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">14.</span> <span class="toc-text">结论 - 静态分析，动态分析</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        [译文]VMProtect2-虚拟机架构的详细分析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">TUGOhost</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-12-06T02:28:25.000Z" class="dt-published" itemprop="datePublished">2022-12-06</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="译文-VMProtect2-虚拟机架构的详细分析"><a href="#译文-VMProtect2-虚拟机架构的详细分析" class="headerlink" title="[译文]VMProtect2-虚拟机架构的详细分析"></a>[译文]VMProtect2-虚拟机架构的详细分析</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://back.engineering/17/05/2021/#deadstore-obfuscation-example">https://back.engineering/17/05/2021/#deadstore-obfuscation-example</a></p>
<p><strong>If there is any infringement, please send an email to <code>tu9oh0st@duck.com</code> and I will promptly remove the article.</strong></p>
<p><strong>如果有任何侵权行为，请发送邮件到<a href="mailto:&#x74;&#117;&#x39;&#x6f;&#x68;&#x30;&#115;&#x74;&#64;&#100;&#117;&#x63;&#x6b;&#46;&#x63;&#111;&#x6d;">&#x74;&#117;&#x39;&#x6f;&#x68;&#x30;&#115;&#x74;&#64;&#100;&#117;&#x63;&#x6b;&#46;&#x63;&#111;&#x6d;</a>，我会及时删除该文章。</strong></p>
</blockquote>
<p>Download link: <a target="_blank" rel="noopener" href="https://githacks.org/vmp2">VMProtect 2 Reverse Engineering</a></p>
<h1 id="Credit-Links-to-Exiiting-Work"><a href="#Credit-Links-to-Exiiting-Work" class="headerlink" title="Credit - Links to Exiiting Work"></a>Credit - Links to Exiiting Work</h1><ul>
<li><a target="_blank" rel="noopener" href="https://twitter.com/w4kfu">Samuel Chevet</a><ul>
<li><a target="_blank" rel="noopener" href="https://webtv.univ-lille.fr/video/7566/inside-vmprotect">Inside VMProtect 2</a><ul>
<li><a target="_blank" rel="noopener" href="https://webtv.univ-lille.fr/plugins/documents/download.php?download=czozNjoiZWIyNTc2Y2EtYzJmMC0xMWU4LTkxNjItMDA1MDU2ODMyYjRmIjs=">Inside VMProtect 2 Slides</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://twitter.com/RolfRolles">Rolf Rolles</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/events/woot09/tech/full_papers/rolles.pdf">Unpacking Virtualization Obfuscators</a></li>
<li><a target="_blank" rel="noopener" href="https://www.msreverseengineering.com/blog/2014/6/23/vmprotect-part-0-basics">VMProtect 2 - Reverse Engineering</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/anatolikalysch">Anatoli Kalysch</a><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/anatolikalysch/VMAttack">VMAttack IDA PRO Plugin</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://twitter.com/_can1357">Can Bölük</a><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/vtil-project">VTIL (Virtual-machine Translation Intermediate Language)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/can1357/NoVmp">NoVmp - A static devirtualizer for VMProtect x64 3.x powered by VTIL.</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://twitter.com/KatyHearthstone/">Katy Hearthstone</a><ul>
<li><a target="_blank" rel="noopener" href="https://katyscode.wordpress.com/2021/01/23/reverse-engineering-adventures-vmprotect-control-flow-obfuscation-case-study-string-algorithm-cryptanalysis-in-honkai-impact-3rd/">VMProtect Control Flow Obfuscation (Case study: string algorithm cryptanalysis in Honkai Impact 3rd)</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/irql0">IRQL0</a><ul>
<li>Helped created vmprofiler v1.0, and helped with general analysis of vm handlers.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/btbd">BTBD</a><ul>
<li>Providing an algorithm to handle deadstore removal with Zydis.</li>
</ul>
</li>
</ul>
<h1 id="序言-意图和目的"><a href="#序言-意图和目的" class="headerlink" title="序言 - 意图和目的"></a>序言 - 意图和目的</h1><p>在深入探讨这篇文章之前，我想就现有的VMProtect 2工作、这篇文章的目的以及我的意图陈述几件事，因为这些似乎有时会被误解和扭曲。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>虽然已经有很多关于VMProtect 2的研究，但我觉得仍有一些信息没有被公开讨论，也没有足够的源代码披露给公众。我在这篇文章中所披露的信息旨在超越一般的架构分析，但要低得多。在这个层面上，人们可以在给定的VMProtect二进制文件中编码自己的虚拟机指令，并可以轻松地拦截和改变虚拟指令的结果。本文讨论的动态分析是基于Samuel Chevet的现有工作，我的动态分析研究和Vmtrace项目只是在他的演讲”Inside VMProtect”中展示的工作基础上的扩展。</p>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>这篇文章无意对VMProtect 2、该软件的创造者或使用该软件的人提出任何负面意见。我钦佩创造者，他们显然有令人印象深刻的技能来创造这样一个产品。</p>
<p>这篇文章也是在这样的印象下创建的，即这里讨论的一切很可能是由私人实体发现的，我不是第一个发现或记录有关VMProtect 2架构的事情。我并不打算把这些信息当作是突破性的或其他人已经发现的东西，恰恰相反。这只是一个现有信息的集合，加上我自己的研究。</p>
<p>既然如此，我谦虚地向你介绍，”VMProtect 2，虚拟机架构的详细分析”。</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><strong>VIP</strong> - 虚拟指令指针，这相当于 x86-64 的 RIP 寄存器，它包含要执行的下一条指令的地址。VMProtect 2 使用本地寄存器 RSI 来保存下一条虚拟指令指针的地址。因此，RSI等同于VIP。</p>
<p><strong>VSP</strong> - 虚拟堆栈指针，这相当于x86-64的RSP寄存器，包含堆栈的地址。VMProtect 2使用本地寄存器RBP来保存虚拟堆栈指针的地址。因此，RBP等同于VSP。</p>
<p><strong>VM Handler</strong> - 一个包含执行虚拟指令的本地代码的例程。例如，VADD64指令将堆栈上的两个值加在一起，并将结果以及RFLAGS存储在堆栈上。</p>
<p><strong>Virtual Instruction</strong> - 也被称为 “虚拟字节码 “是由虚拟机解释并随后执行的字节。每个虚拟指令至少由一个或多个操作数组成。第一个操作数包含该指令的操作码。</p>
<p><strong>Virtual Opcode</strong> - 每个虚拟指令的第一个操作数。这是vm处理程序的索引。VMProtect 2操作码的大小总是一个字节。</p>
<p><strong>IMM &#x2F; Immediate Value</strong> - 编码到虚拟指令中的一个值，通过这个值进行操作，例如将所述值加载到堆栈或虚拟寄存器中。虚拟指令如LREG、SREG和LCONST都有即时值。</p>
<p><strong>Transformations</strong> - 本篇文章中使用的术语 “转换 “特指为解密虚拟指令的操作数和vm处理程序表项而进行的操作。这些转换包括add, sub, inc, dec, not, neg, shl, shr, ror, rol, 以及最后的BSWAP。变换的大小为1、2、4和8字节。变换也可以有与之相关的即时&#x2F;恒定值，如 “xor rax, 0x123456”，或 “add rax, 0x123456”。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>VMProtect 2是一个基于虚拟机的x86混淆器，它将x86指令转换为RISC、堆栈机的指令集。每个受保护的二进制文件都有一套独特的加密虚拟机指令，并有独特的混淆功能。该项目旨在披露每一个VMProtect 2二进制文件中非常重要的签名，以帮助进一步研究。本文还将简要地讨论不同类型的VMProtect 2混淆。所有去混淆的技术都是专门针对虚拟机例程的，对一般被混淆的例程不起作用，特别是其中有真正的JCC的例程。</p>
<h1 id="混淆-Deadstore，不透明的分支"><a href="#混淆-Deadstore，不透明的分支" class="headerlink" title="混淆-Deadstore，不透明的分支"></a>混淆-Deadstore，不透明的分支</h1><p>VMProtect 2 在大多数情况下使用两种混淆类型，第一种是Deadstore，第二种是不透明的分支。在整个混淆的程序中，你可以看到几条指令后有一个JCC，然后是另一组指令后有另一个JCC。不透明分支的另一个贡献是影响FLAGS寄存器的随机指令。你到处都可以看到这些小家伙。它们大多是位测试指令，无用的比较，以及设置&#x2F;清除标志的指令。</p>
<h2 id="不透明分支混淆实例"><a href="#不透明分支混淆实例" class="headerlink" title="不透明分支混淆实例"></a>不透明分支混淆实例</h2><p>在这个不透明分支混淆实例中，我将介绍 VMProtect 2 不透明分支的外观，其他因素如 rflags 的状态，以及最重要的是，如何确定你看到的是不透明分支还是合法的 JCC。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:00000001400073B4 D0 C8                  ror     al, 1</span><br><span class="line">.vmp0:00000001400073B6 0F CA                  bswap   edx</span><br><span class="line">.vmp0:00000001400073B8 66 0F CA               bswap   dx</span><br><span class="line">.vmp0:00000001400073BB 66 0F BE D2            movsx   dx, dl</span><br><span class="line">.vmp0:00000001400073BF 48 FF C6               inc     rsi</span><br><span class="line">.vmp0:00000001400073C2 48 0F BA FA 0F         btc     rdx, 0Fh</span><br><span class="line">.vmp0:00000001400073C7 F6 D8                  neg     al</span><br><span class="line">.vmp0:00000001400073C9 0F 81 6F D0 FF FF      jno     loc_14000443E</span><br><span class="line">.vmp0:00000001400073CF 66 C1 FA 04            sar     dx, 4</span><br><span class="line">.vmp0:00000001400073D3 81 EA EC 94 CD 47      sub     edx, 47CD94ECh</span><br><span class="line">.vmp0:00000001400073D9 28 C3                  sub     bl, al</span><br><span class="line">.vmp0:00000001400073DB D2 F6                  sal     dh, cl</span><br><span class="line">.vmp0:00000001400073DD 66 0F BA F2 0E         btr     dx, 0Eh</span><br><span class="line">.vmp0:00000001400073E2 8B 14 38               mov     edx, [rax+rdi]</span><br></pre></td></tr></table></figure>

<p>考虑一下上述混淆的代码。注意JNO分支。如果你在ida中跟踪这个分支，并将指令与JNO之后的指令进行比较，你可以看到这个分支是无用的，因为两个路径执行的是同样的有意义的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loc_14000443E:</span><br><span class="line">.vmp0:000000014000443E F5                     cmc</span><br><span class="line">.vmp0:000000014000443F 0F B3 CA               btr     edx, ecx</span><br><span class="line">.vmp0:0000000140004442 0F BE D3               movsx   edx, bl</span><br><span class="line">.vmp0:0000000140004445 66 21 F2               and     dx, si</span><br><span class="line">.vmp0:0000000140004448 28 C3                  sub     bl, al</span><br><span class="line">.vmp0:000000014000444A 48 81 FA 38 04 AA 4E   cmp     rdx, 4EAA0438h</span><br><span class="line">.vmp0:0000000140004451 48 8D 90 90 50 F5 BB   lea     rdx, [rax-440AAF70h]</span><br><span class="line">.vmp0:0000000140004458 D2 F2                  sal     dl, cl</span><br><span class="line">.vmp0:000000014000445A D2 C2                  rol     dl, cl</span><br><span class="line">.vmp0:000000014000445C 8B 14 38               mov     edx, [rax+rdi]</span><br></pre></td></tr></table></figure>

<p>如果你看得足够仔细，你可以看到有几条指令在两个分支中都有。要确定哪些代码是Deadstore，哪些代码是需要的，可能很困难，但是如果你在ida中选择一个寄存器，并查看它在你所看的指令之前被写入的所有地方，你可以删除所有其他的写入指令，直到有一个对该寄存器的读取。现在，回到这个例子，在这种情况下，以下指令才是重要的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140004448 28 C3                  sub     bl, al</span><br><span class="line">.vmp0:000000014000445C 8B 14 38               mov     edx, [rax+rdi]</span><br></pre></td></tr></table></figure>

<p>这些不透明分支的产生使得有重复的指令出现。对于每个代码路径，还有更多的死库混淆以及不透明的条件和其他影响RFLAGS的指令。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/1.png"></p>
<h2 id="Deadstore-混淆示例"><a href="#Deadstore-混淆示例" class="headerlink" title="Deadstore 混淆示例"></a>Deadstore 混淆示例</h2><p>除了不透明的位测试和比较，VMProtect 2 deadstore混淆在指令流中增加了最多的垃圾。这些指令没有任何作用，可以很容易地被发现并被手工删除。请考虑以下情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140004149 66 D3 D7               rcl     di, cl</span><br><span class="line">.vmp0:000000014000414C 58                     pop     rax</span><br><span class="line">.vmp0:000000014000414D 66 41 0F A4 DB 01      shld    r11w, bx, 1</span><br><span class="line">.vmp0:0000000140004153 41 5B                  pop     r11</span><br><span class="line">.vmp0:0000000140004155 80 E6 CA               and     dh, 0CAh</span><br><span class="line">.vmp0:0000000140004158 66 F7 D7               not     di</span><br><span class="line">.vmp0:000000014000415B 5F                     pop     rdi</span><br><span class="line">.vmp0:000000014000415C 66 41 C1 C1 0C         rol     r9w, 0Ch</span><br><span class="line">.vmp0:0000000140004161 F9                     stc</span><br><span class="line">.vmp0:0000000140004162 41 58                  pop     r8</span><br><span class="line">.vmp0:0000000140004164 F5                     cmc</span><br><span class="line">.vmp0:0000000140004165 F8                     clc</span><br><span class="line">.vmp0:0000000140004166 66 41 C1 E1 0B         shl     r9w, 0Bh</span><br><span class="line">.vmp0:000000014000416B 5A                     pop     rdx</span><br><span class="line">.vmp0:000000014000416C 66 81 F9 EB D2         cmp     cx, 0D2EBh</span><br><span class="line">.vmp0:0000000140004171 48 0F A3 F1            bt      rcx, rsi</span><br><span class="line">.vmp0:0000000140004175 41 59                  pop     r9</span><br><span class="line">.vmp0:0000000140004177 66 41 21 E2            and     r10w, sp</span><br><span class="line">.vmp0:000000014000417B 41 C1 D2 10            rcl     r10d, 10h</span><br><span class="line">.vmp0:000000014000417F 41 5A                  pop     r10</span><br><span class="line">.vmp0:0000000140004181 66 0F BA F9 0C         btc     cx, 0Ch</span><br><span class="line">.vmp0:0000000140004186 49 0F CC               bswap   r12</span><br><span class="line">.vmp0:0000000140004189 48 3D 97 74 7D C7      cmp     rax, 0FFFFFFFFC77D7497h</span><br><span class="line">.vmp0:000000014000418F 41 5C                  pop     r12</span><br><span class="line">.vmp0:0000000140004191 66 D3 C1               rol     cx, cl</span><br><span class="line">.vmp0:0000000140004194 F5                     cmc</span><br><span class="line">.vmp0:0000000140004195 66 0F BA F5 01         btr     bp, 1</span><br><span class="line">.vmp0:000000014000419A 66 41 D3 FE            sar     r14w, cl</span><br><span class="line">.vmp0:000000014000419E 5D                     pop     rbp</span><br><span class="line">.vmp0:000000014000419F 66 41 29 F6            sub     r14w, si</span><br><span class="line">.vmp0:00000001400041A3 66 09 F6               or      si, si</span><br><span class="line">.vmp0:00000001400041A6 01 C6                  add     esi, eax</span><br><span class="line">.vmp0:00000001400041A8 66 0F C1 CE            xadd    si, cx</span><br><span class="line">.vmp0:00000001400041AC 9D                     popfq</span><br><span class="line">.vmp0:00000001400041AD 0F 9F C1               setnle  cl</span><br><span class="line">.vmp0:00000001400041B0 0F 9E C1               setle   cl</span><br><span class="line">.vmp0:00000001400041B3 4C 0F BE F0            movsx   r14, al</span><br><span class="line">.vmp0:00000001400041B7 59                     pop     rcx</span><br><span class="line">.vmp0:00000001400041B8 F7 D1                  not     ecx</span><br><span class="line">.vmp0:00000001400041BA 59                     pop     rcx</span><br><span class="line">.vmp0:00000001400041BB 4C 8D A8 ED 19 28 C9   lea     r13, [rax-36D7E613h]</span><br><span class="line">.vmp0:00000001400041C2 66 F7 D6               not     si</span><br><span class="line">.vmp0:00000001400041CB 41 5E                  pop     r14</span><br><span class="line">.vmp0:00000001400041CD 66 F7 D6               not     si</span><br><span class="line">.vmp0:00000001400041D0 66 44 0F BE EA         movsx   r13w, dl</span><br><span class="line">.vmp0:00000001400041D5 41 BD B2 6B 48 B7      mov     r13d, 0B7486BB2h</span><br><span class="line">.vmp0:00000001400041DB 5E                     pop     rsi</span><br><span class="line">.vmp0:00000001400041DC 66 41 BD CA 44         mov     r13w, 44CAh</span><br><span class="line">.vmp0:0000000140007AEA 4C 8D AB 31 11 63 14   lea     r13, [rbx+14631131h]</span><br><span class="line">.vmp0:0000000140007AF1 41 0F CD               bswap   r13d</span><br><span class="line">.vmp0:0000000140007AF4 41 5D                  pop     r13</span><br><span class="line">.vmp0:0000000140007AF6 C3                     retn</span><br></pre></td></tr></table></figure>

<p>让我们从头开始，一条一条的指令。在0x140004149的第一条指令是 “RCL - Rotate Left Carry”。这条指令影响到FLAGS寄存器和DI。让我们看看下一次DI被引用的时候。它是读还是写？下一次对DI的引用是位于0x140004158的NOT指令。NOT读和写DI，到目前为止两条指令都是有效的。下一个引用DI的指令是POP指令。这一点很关键，因为在这条POP指令之前对RDI的所有写都可以从指令流中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000414C 58                     pop     rax</span><br><span class="line">.vmp0:000000014000414D 66 41 0F A4 DB 01      shld    r11w, bx, 1</span><br><span class="line">.vmp0:0000000140004153 41 5B                  pop     r11</span><br><span class="line">.vmp0:0000000140004155 80 E6 CA               and     dh, 0CAh</span><br><span class="line">.vmp0:000000014000415B 5F                     pop     rdi</span><br></pre></td></tr></table></figure>

<p>下一条指令是<strong>POP RAX</strong>，位于0x14000414C。RAX在整个指令流中从未被写入，只是被读出。因为它有一个读的依赖性，所以这条指令不能被删除。进入下一条指令，SHLD - 双精度左移(double precision shift left)，对R11有写依赖，对BX有读依赖。下一条引用R11的指令是0x140004153的POP R11。我们可以删除SHLD指令，因为它是Deadstore。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000414C 58                     pop     rax</span><br><span class="line">.vmp0:0000000140004153 41 5B                  pop     r11</span><br><span class="line">.vmp0:0000000140004155 80 E6 CA               and     dh, 0CAh</span><br><span class="line">.vmp0:000000014000415B 5F                     pop     rdi</span><br></pre></td></tr></table></figure>

<p>现在只要对每一条指令重复这个过程。最终的结果应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000414C 58                                            pop     rax</span><br><span class="line">.vmp0:0000000140004153 41 5B                                         pop     r11</span><br><span class="line">.vmp0:000000014000415B 5F                                            pop     rdi</span><br><span class="line">.vmp0:0000000140004162 41 58                                         pop     r8</span><br><span class="line">.vmp0:000000014000416B 5A                                            pop     rdx</span><br><span class="line">.vmp0:0000000140004175 41 59                                         pop     r9</span><br><span class="line">.vmp0:000000014000417F 41 5A                                         pop     r10</span><br><span class="line">.vmp0:000000014000418F 41 5C                                         pop     r12</span><br><span class="line">.vmp0:000000014000419E 5D                                            pop     rbp</span><br><span class="line">.vmp0:00000001400041AC 9D                                            popfq</span><br><span class="line">.vmp0:00000001400041B7 59                                            pop     rcx</span><br><span class="line">.vmp0:00000001400041B7 59                                            pop     rcx</span><br><span class="line">.vmp0:00000001400041CB 41 5E                                         pop     r14</span><br><span class="line">.vmp0:00000001400041DB 5E                                            pop     rsi</span><br><span class="line">.vmp0:0000000140007AF4 41 5D                                         pop     r13</span><br><span class="line">.vmp0:0000000140007AF6 C3                                            retn</span><br></pre></td></tr></table></figure>

<p>这种方法对于消除Deadstore混淆并不完美，因为有第二个POP RCX在上面这个结果中缺失。POP和PUSH指令是特殊情况，不应该从指令流中发出，因为这些指令也会改变RSP。这种去除死库的方法也只适用于vm_entry和vm handler。这不能应用于一般的混淆程序。同样，这个方法不会对任何被混淆的例程起作用，它是专门为vm_entry和vm handlers定制的，因为这些例程中没有合法的JCC。</p>
<h1 id="概述-VMProtect-2-虚拟机"><a href="#概述-VMProtect-2-虚拟机" class="headerlink" title="概述 - VMProtect 2 虚拟机"></a>概述 - VMProtect 2 虚拟机</h1><p>虚拟指令由被称为 “vm handlers”的虚拟指令处理程序进行解密和解释。虚拟机是一个基于RISC的堆栈机，带有scratch寄存器。在vm-entries之前，虚拟指令的加密RVA（相对虚拟地址，relative virtual address）被推入堆栈，所有的通用寄存器以及标志被推入堆栈。VIP被解密，计算，并加载到RSI。然后在RBX中启动一个滚动解密密钥，用来解密每一条虚拟指令的每一个操作数。滚动解密密钥通过与解密的操作数值进行转换来更新。<br><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/22.png"></p>
<h2 id="滚动式解密"><a href="#滚动式解密" class="headerlink" title="滚动式解密"></a>滚动式解密</h2><p>VMProtect 2使用一个滚动解密密钥。该密钥用于解密虚拟指令操作数，随后防止任何形式的hook，因为如果任何虚拟指令被不按顺序执行，滚动解密密钥将变得无效，导致虚拟操作数的进一步解密也无效。</p>
<h2 id="本地寄存器的使用"><a href="#本地寄存器的使用" class="headerlink" title="本地寄存器的使用"></a>本地寄存器的使用</h2><p>在虚拟机内部的执行过程中，一些本地寄存器是专门用于虚拟机机制的，比如虚拟指令指针和虚拟栈。在本节中，我将讨论这些本地寄存器和它们在虚拟机中的用途。</p>
<h3 id="非易失性寄存器–有特定用途的寄存器"><a href="#非易失性寄存器–有特定用途的寄存器" class="headerlink" title="非易失性寄存器–有特定用途的寄存器"></a>非易失性寄存器–有特定用途的寄存器</h3><p>首先，RSI总是被用来作为虚拟指令指针。操作数从存储在RSI中的地址获取。装入RSI的初始值由vm_entry完成。</p>
<p>RBP用于虚拟堆栈指针，存储在RBP中的地址实际上是本地堆栈内存。在分配从头开始的寄存器之前，RBP与RSP一起被加载。这给我们带来了包含scratch寄存器的RDI。RDI中的地址在vm_entry中也被初始化，并被设置为本地堆栈内部的一个地址。</p>
<p>R12被加载了vm处理表的线性虚拟地址。这是在vm_entry中完成的，在虚拟机内部执行的整个过程中，R12将包含这个地址。</p>
<p>R13在vm_entry中被加载了模块基址的线性虚拟地址，并且在虚拟机内部的整个执行过程中不会被改变。</p>
<p>RBX是一个非常特殊的寄存器，它包含滚动解密密钥。在每条虚拟指令的每个操作数被解密后，RBX通过对其进行转换来更新其解密的操作数的值。</p>
<h3 id="易失性寄存器-临时寄存器"><a href="#易失性寄存器-临时寄存器" class="headerlink" title="易失性寄存器 - 临时寄存器"></a>易失性寄存器 - 临时寄存器</h3><p>RAX、RCX和RDX被用作虚拟机内部的临时寄存器，但是RAX被用来对其他寄存器进行非常特殊的临时操作。RAX用于解密虚拟指令的操作数，AL具体用于解密虚拟指令的操作码。<br><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/2.png"></p>
<h2 id="vm-entry-虚拟机的入口"><a href="#vm-entry-虚拟机的入口" class="headerlink" title="vm_entry - 虚拟机的入口"></a>vm_entry - 虚拟机的入口</h2><p>vm_entry是虚拟机架构中一个非常重要的组成部分。在进入虚拟机之前，一个加密的RVA到虚拟指令被推到堆栈中。这个RVA是一个四字节的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000822C 68 FA 01 00 89         push    0FFFFFFFF890001FAh</span><br></pre></td></tr></table></figure>

<p>在这个值被推入堆栈后，一个jmp指令被执行以开始执行vm_entry。我在上面详细解释过vm_entry会被扁平化混淆处理。然后删除deadstor代码，我们可以得到一个干净的vm_entry的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x822c :                                    push 0xFFFFFFFF890001FA</span><br><span class="line">&gt; 0x7fc9 :                                    push 0x45D3BF1F</span><br><span class="line">&gt; 0x48e4 :                                    push r13</span><br><span class="line">&gt; 0x4690 :                                    push rsi</span><br><span class="line">&gt; 0x4e53 :                                    push r14</span><br><span class="line">&gt; 0x74fb :                                    push rcx</span><br><span class="line">&gt; 0x607c :                                    push rsp</span><br><span class="line">&gt; 0x4926 :                                    pushfq</span><br><span class="line">&gt; 0x4dc2 :                                    push rbp</span><br><span class="line">&gt; 0x5c8c :                                    push r12</span><br><span class="line">&gt; 0x52ac :                                    push r10</span><br><span class="line">&gt; 0x51a5 :                                    push r9</span><br><span class="line">&gt; 0x5189 :                                    push rdx</span><br><span class="line">&gt; 0x7d5f :                                    push r8</span><br><span class="line">&gt; 0x4505 :                                    push rdi</span><br><span class="line">&gt; 0x4745 :                                    push r11</span><br><span class="line">&gt; 0x478b :                                    push rax</span><br><span class="line">&gt; 0x7a53 :                                    push rbx</span><br><span class="line">&gt; 0x500d :                                    push r15</span><br><span class="line">&gt; 0x6030 :                                    push [0x00000000000018E2]</span><br><span class="line">&gt; 0x593a :                                    mov rax, 0x7FF634270000</span><br><span class="line">&gt; 0x5955 :                                    mov r13, rax</span><br><span class="line">&gt; 0x5965 :                                    push rax</span><br><span class="line">&gt; 0x596f :                                    mov esi, [rsp+0xA0]</span><br><span class="line">&gt; 0x5979 :                                    not esi</span><br><span class="line">&gt; 0x5985 :                                    neg esi</span><br><span class="line">&gt; 0x598d :                                    ror esi, 0x1A</span><br><span class="line">&gt; 0x599e :                                    mov rbp, rsp</span><br><span class="line">&gt; 0x59a8 :                                    sub rsp, 0x140</span><br><span class="line">&gt; 0x59b5 :                                    and rsp, 0xFFFFFFFFFFFFFFF0</span><br><span class="line">&gt; 0x59c1 :                                    mov rdi, rsp</span><br><span class="line">&gt; 0x59cb :                                    lea r12, [0x0000000000000AA8]</span><br><span class="line">&gt; 0x59df :                                    mov rax, 0x100000000</span><br><span class="line">&gt; 0x59ec :                                    add rsi, rax</span><br><span class="line">&gt; 0x59f3 :                                    mov rbx, rsi</span><br><span class="line">&gt; 0x59fa :                                    add rsi, [rbp]</span><br><span class="line">&gt; 0x5a05 :                                    mov al, [rsi]</span><br><span class="line">&gt; 0x5a0a :                                    xor al, bl</span><br><span class="line">&gt; 0x5a11 :                                    neg al</span><br><span class="line">&gt; 0x5a19 :                                    rol al, 0x05</span><br><span class="line">&gt; 0x5a26 :                                    inc al</span><br><span class="line">&gt; 0x5a2f :                                    xor bl, al</span><br><span class="line">&gt; 0x5a34 :                                    movzx rax, al</span><br><span class="line">&gt; 0x5a41 :                                    mov rdx, [r12+rax*8]</span><br><span class="line">&gt; 0x5a49 :                                    xor rdx, 0x7F3D2149</span><br><span class="line">&gt; 0x5507 :                                    inc rsi</span><br><span class="line">&gt; 0x7951 :                                    add rdx, r13</span><br><span class="line">&gt; 0x7954 :                                    jmp rdx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如预期的那样，所有的寄存器和RFLAGS都被推到了堆栈中。最后一次推送将8个字节的0放在堆栈上，而不是我最初预期的重新定位。这些推送发生的顺序在每个版本中都是独一无二的，但是最后推送的8个0在所有二进制文件中总是相同的。这是一个非常稳定的签名，可以确定一般寄存器推送的结束时间。下面是我在本段中提到的指令的确切序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x48e4 :                                    push r13</span><br><span class="line">&gt; 0x4690 :                                    push rsi</span><br><span class="line">&gt; 0x4e53 :                                    push r14</span><br><span class="line">&gt; 0x74fb :                                    push rcx</span><br><span class="line">&gt; 0x607c :                                    push rsp</span><br><span class="line">&gt; 0x4926 :                                    pushfq</span><br><span class="line">&gt; 0x4dc2 :                                    push rbp</span><br><span class="line">&gt; 0x5c8c :                                    push r12</span><br><span class="line">&gt; 0x52ac :                                    push r10</span><br><span class="line">&gt; 0x51a5 :                                    push r9</span><br><span class="line">&gt; 0x5189 :                                    push rdx</span><br><span class="line">&gt; 0x7d5f :                                    push r8</span><br><span class="line">&gt; 0x4505 :                                    push rdi</span><br><span class="line">&gt; 0x4745 :                                    push r11</span><br><span class="line">&gt; 0x478b :                                    push rax</span><br><span class="line">&gt; 0x7a53 :                                    push rbx</span><br><span class="line">&gt; 0x500d :                                    push r15</span><br><span class="line">&gt; 0x6030 :                                    push [0x00000000000018E2] ; pushes 0’s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在所有的寄存器和RFLAGS被推入堆栈后，模块的基本地址被加载到R13。这发生在每一个二进制文件中，在虚拟机的执行过程中，R13总是包含模块的基地址。模块的基地址也被推入堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x593a :                                    mov rax, 0x7FF634270000</span><br><span class="line">&gt; 0x5955 :                                    mov r13, rax</span><br><span class="line">&gt; 0x5965 :                                    push rax</span><br></pre></td></tr></table></figure>

<p>接下来，要执行的虚拟指令的相对虚拟地址被解密。这是通过从RSP+0xA0加载32位RVA到ESI来完成的。这是一个非常重要的签名，可以很容易找到。然后对ESI进行三次转换以得到虚拟指令的解密RVA。这三个转换在每个二进制中是唯一的。然而，总是有三个转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x596f :                                    mov esi, [rsp+0xA0]</span><br><span class="line">&gt; 0x5979 :                                    not esi</span><br><span class="line">&gt; 0x5985 :                                    neg esi</span><br><span class="line">&gt; 0x598d :                                    ror esi, 0x1A</span><br></pre></td></tr></table></figure>

<p>此外，接下来发生的值得注意的操作是在堆栈上为从头寄存器分配空间。RSP总是被移到RBP，然后RSP被减去0x140。然后按16个字节对齐。做完这些后，地址被移入RDI。在虚拟机的执行过程中，RDI总是包含一个指向scratch寄存器的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x599e :                                    mov rbp, rsp</span><br><span class="line">&gt; 0x59a8 :                                    sub rsp, 0x140</span><br><span class="line">&gt; 0x59b5 :                                    and rsp, 0xFFFFFFFFFFFFFFF0</span><br><span class="line">&gt; 0x59c1 :                                    mov rdi, rsp</span><br></pre></td></tr></table></figure>

<p>下一个值得注意的操作是将vm处理程序表的地址加载到R12中。这是在每个单一的VMProtect 2二进制文件上进行的。R12总是包含vm处理表的线性虚拟地址。这是另一个重要的签名，可用于找到vm处理程序表的位置，非常简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x59cb :                                    lea r12, [0x0000000000000AA8]</span><br></pre></td></tr></table></figure>

<p>然后对RSI进行另一个操作来计算VIP。在PE头中，有一个叫做 “可选头 “的头。它包含各种各样的信息。其中一个字段被称为 “ImageBase”。如果在这个字段中有任何高于32的位，这些位就会被加到RSI中。例如，vmptest.vmp.exe ImageBase字段包含值0x140000000。因此，作为计算的一部分，0x100000000被添加到RSI中。如果一个ImageBase字段包含少于32位的值，那么RSI将被添加到0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x59df :                                    mov rax, 0x100000000</span><br><span class="line">&gt; 0x59ec :                                    add rsi, rax</span><br></pre></td></tr></table></figure>

<p>在对RSI做了这个加法之后，一个小的、有点不重要的指令被执行。这条指令将虚拟指令的线性虚拟地址加载到RBX中。现在，RBX有一个非常特殊的用途，它包含了 “滚动解密 “的密钥。正如你所看到的，加载到RBX的第一个值将是虚拟指令本身的地址! 不是线性虚拟地址，而只是包括ImageBase字段前32位的RVA。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x59f3 :                                    mov rbx, rsi</span><br></pre></td></tr></table></figure>

<p>接下来，vmp模块的基地址被添加到RSI中，计算出虚拟指令的完整线性虚拟地址。记住，RBP包含了在分配scratch空间之前的RSP的地址。这时模块的基地址在堆栈的顶部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x59fa :                                    add rsi, [rbp]</span><br></pre></td></tr></table></figure>

<p>vm_entry的细节到此为止，这个例程的下一部分实际上被称为 “calc_vm_handler”，在除了vm_exit指令之外的每一条虚拟指令之后执行。</p>
<h2 id="calc-jmp-解密Vm-Handler的索引"><a href="#calc-jmp-解密Vm-Handler的索引" class="headerlink" title="calc_jmp - 解密Vm Handler的索引"></a>calc_jmp - 解密Vm Handler的索引</h2><p>calc_jmp是vm_entry例程的一部分，然而它不仅仅被vm_entry例程所提及。每个vm处理程序最终都会跳转到calc_jmp（除了vm_exit）。这段代码负责解密每条虚拟指令的操作码，以及索引到vm处理程序表，解密vm处理程序表条目并跳转到结果的vm处理程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5a05 :                                    mov al, [rsi]</span><br><span class="line">&gt; 0x5a0a :                                    xor al, bl</span><br><span class="line">&gt; 0x5a11 :                                    neg al</span><br><span class="line">&gt; 0x5a19 :                                    rol al, 0x05</span><br><span class="line">&gt; 0x5a26 :                                    inc al</span><br><span class="line">&gt; 0x5a2f :                                    xor bl, al</span><br><span class="line">&gt; 0x5a34 :                                    movzx rax, al</span><br><span class="line">&gt; 0x5a41 :                                    mov rdx, [r12+rax*8]</span><br><span class="line">&gt; 0x5a49 :                                    xor rdx, 0x7F3D2149</span><br><span class="line">&gt; 0x5507 :                                    inc rsi</span><br><span class="line">&gt; 0x7951 :                                    add rdx, r13</span><br><span class="line">&gt; 0x7954 :                                    jmp rdx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码的第一条指令从RSI中读出一个字节，如你所知，这是VIP。这个字节是一个加密的操作码。换句话说，它是一个进入vm处理程序表的加密索引。总共有5个转换被完成。第一个转换总是应用于加密的操作码和RBX中的值作为源。这就是 “滚动加密 “的作用。值得注意的是，加载到RBX的第一个值是虚拟指令的RVA。因此BL将包含这个RVA的最后一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5a05 :                                    mov al, [rsi]</span><br><span class="line">&gt; 0x5a2f :                                    xor bl, al ; transformation is unique to each build</span><br></pre></td></tr></table></figure>

<p>接下来，三个转换被直接应用于AL。这些转换可以有即时的值，但是从来没有其他寄存器的值加入这些转换中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5a11 :                                    neg al</span><br><span class="line">&gt; 0x5a19 :                                    rol al, 0x05</span><br><span class="line">&gt; 0x5a26 :                                    inc al</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一个转换是应用于存储在RBX中的滚动加密密钥。这个变换和第一个变换是一样的。然而，寄存器的位置互换。最终的结果是解密的vm处理程序索引。然后AL的值被零扩展到RAX的其余部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5a2f :                                    xor bl, al</span><br><span class="line">&gt; 0x5a34 :                                    movzx rax, al</span><br></pre></td></tr></table></figure>

<p>现在，进入vm handler表的索引已经被解密，vm handler条目本身必须被获取和解密。对这些vm处理程序表条目只进行了一次转换。在这些转换中没有使用任何寄存器的值。加密后的vm表项值被加载到的寄存器总是RCX或RDX。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5a41 :                                    mov rdx, [r12+rax*8]</span><br><span class="line">&gt; 0x5a49 :                                    xor rdx, 0x7F3D2149</span><br></pre></td></tr></table></figure>

<p>现在，VIP被推进。VIP可以向前或向后推进，推进操作本身可以是LEA、INC、DEC、ADD或SUB指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x5507 :                                    inc rsi</span><br></pre></td></tr></table></figure>

<p>最后，模块的基地址被添加到解密后的vm处理程序RVA中，然后执行JMP，开始执行这个vm处理程序。同样，RDX或RCX总是被用于这个ADD和JMP。这是虚拟机中另一个重要的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x7951 :                                    add rdx, r13</span><br><span class="line">&gt; 0x7954 :                                    jmp rdx</span><br></pre></td></tr></table></figure>

<p>至此，calc_jmp的代码片段规范结束。正如你所看到的，有一些非常重要的签名，使用Zydis就可以找到。特别是对vm handler表项进行的解密，以及对这些加密值的获取。</p>
<h2 id="vm-exit-离开虚拟机"><a href="#vm-exit-离开虚拟机" class="headerlink" title="vm_exit - 离开虚拟机"></a>vm_exit - 离开虚拟机</h2><p>与vm_entry不同，vm_exit是一个非常简单的程序。这个例程简单地将所有寄存器POP回原位，包括RFLAGS。有一些多余的POP是用来清除堆栈中的模块基数、padding以及RSP的，因为它们不需要了。pops发生的顺序与它们被vm_entry推入堆栈的顺序相反。在vm_exit例程之前，返回地址被计算并加载到堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000635F 48 89 EC               mov     rsp, rbp</span><br><span class="line">.vmp0:0000000140006371 58                     pop     rax ; pop module base of the stack</span><br><span class="line">.vmp0:000000014000637F 5B                     pop     rbx ; pop zero’s off the stack</span><br><span class="line">.vmp0:0000000140006387 41 5F                  pop     r15</span><br><span class="line">.vmp0:0000000140006393 5B                     pop     rbx</span><br><span class="line">.vmp0:000000014000414C 58                     pop     rax</span><br><span class="line">.vmp0:0000000140004153 41 5B                  pop     r11</span><br><span class="line">.vmp0:000000014000415B 5F                     pop     rdi</span><br><span class="line">.vmp0:0000000140004162 41 58                  pop     r8</span><br><span class="line">.vmp0:000000014000416B 5A                     pop     rdx</span><br><span class="line">.vmp0:0000000140004175 41 59                  pop     r9</span><br><span class="line">.vmp0:000000014000417F 41 5A                  pop     r10</span><br><span class="line">.vmp0:000000014000418F 41 5C                  pop     r12</span><br><span class="line">.vmp0:000000014000419E 5D                     pop     rbp</span><br><span class="line">.vmp0:00000001400041AC 9D                     popfq</span><br><span class="line">.vmp0:00000001400041B7 59                     pop     rcx ; pop RSP off the stack.</span><br><span class="line">.vmp0:00000001400041BA 59                     pop     rcx</span><br><span class="line">.vmp0:00000001400041CB 41 5E                  pop     r14</span><br><span class="line">.vmp0:00000001400041DB 5E                     pop     rsi</span><br><span class="line">.vmp0:0000000140007AF4 41 5D                  pop     r13</span><br><span class="line">.vmp0:0000000140007AF6 C3                     retn</span><br></pre></td></tr></table></figure>

<h2 id="check-vsp-重定位scratch寄存器"><a href="#check-vsp-重定位scratch寄存器" class="headerlink" title="check_vsp - 重定位scratch寄存器"></a>check_vsp - 重定位scratch寄存器</h2><p>将任何新值放在堆栈上的Vm handlers将在vm handlers执行后有一个堆栈检查。这个例程检查堆栈是否侵占了scratch寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:00000001400044AA 48 8D 87 E0 00 00 00       lea     rax, [rdi+0E0h]</span><br><span class="line">.vmp0:00000001400044B2 48 39 C5                   cmp     rbp, rax</span><br><span class="line">.vmp0:000000014000429D 0F 87 5B 17 00 00          ja      calc_jmp</span><br><span class="line">.vmp0:00000001400042AC 48 89 E2                   mov     rdx, rsp</span><br><span class="line">.vmp0:0000000140005E5F 48 8D 8F C0 00 00 00       lea     rcx, [rdi+0C0h]</span><br><span class="line">.vmp0:0000000140005E75 48 29 D1                   sub     rcx, rdx</span><br><span class="line">.vmp0:000000014000464C 48 8D 45 80                lea     rax, [rbp-80h]</span><br><span class="line">.vmp0:0000000140004655 24 F0                      and     al, 0F0h</span><br><span class="line">.vmp0:000000014000465F 48 29 C8                   sub     rax, rcx</span><br><span class="line">.vmp0:000000014000466B 48 89 C4                   mov     rsp, rax</span><br><span class="line">.vmp0:0000000140004672 9C                         pushfq</span><br><span class="line">.vmp0:000000014000467C 56                         push    rsi</span><br><span class="line">.vmp0:0000000140004685 48 89 D6                   mov     rsi, rdx</span><br><span class="line">.vmp0:00000001400057D6 48 8D BC 01 40 FF FF FF    lea     rdi, [rcx+rax-0C0h]</span><br><span class="line">.vmp0:00000001400051FC 57                         push    rdi</span><br><span class="line">.vmp0:000000014000520C 48 89 C7                   mov     rdi, rax</span><br><span class="line">.vmp0:0000000140004A34 F3 A4                      rep movsb</span><br><span class="line">.vmp0:0000000140004A3E 5F                         pop     rdi</span><br><span class="line">.vmp0:0000000140004A42 5E                         pop     rsi</span><br><span class="line">.vmp0:0000000140004A48 9D                         popfq</span><br><span class="line">.vmp0:0000000140004A49 E9 B0 0F 00 00             jmp     calc_jmp</span><br></pre></td></tr></table></figure>

<p>注意 “movsb “的用法，它被用来复制从头开始寄存器的内容。</p>
<h2 id="虚拟指令-操作码、操作数、规格"><a href="#虚拟指令-操作码、操作数、规格" class="headerlink" title="虚拟指令 - 操作码、操作数、规格"></a>虚拟指令 - 操作码、操作数、规格</h2><p>虚拟指令由两个或多个操作数组成。第一个操作数是虚拟指令的操作码。操作码是8位的无符号值，当被解密时，它是进入vm处理表的索引。可以有第二个操作数，这是一个1到8字节的即时值。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/3.png"></p>
<p>所有操作数都是加密的，必须用滚动的解密密钥来解密。解密是在calc_jmp以及vm处理程序本身内部进行的。进行解密的Vm处理程序将只对即时值而不是操作码进行操作。</p>
<h3 id="操作符解密-Transformations"><a href="#操作符解密-Transformations" class="headerlink" title="操作符解密 - Transformations"></a>操作符解密 - Transformations</h3><p>VMProtect 2使用滚动解密密钥对其虚拟指令进行加密。该密钥位于RBX中，最初被设置为虚拟指令的地址。为解密操作数所做的转换包括XOR、NEG、NOT、AND、ROR、ROL、SHL、SHR、ADD、SUB、INC、DEC和BSWAP。当一个操作数被解密时，应用于该操作数的第一个转换包括滚动解密密钥。因此，只有XOR, AND, ROR, ROL, ADD, 和SUB是应用于操作数的第一个转换。然后，总是有三个转换直接应用于操作数。在这个阶段，操作数被完全解密，RAX中的值将保持解密的操作数值。最后，通过将滚动解密密钥与完全解密的操作数值进行转换，更新滚动解密密钥。一个例子是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140005A0A 30 D8                  xor     al, bl ; decrypt using rolling key...</span><br><span class="line">.vmp0:0000000140005A11 F6 D8                  neg     al ; 1/3 transformations...</span><br><span class="line">.vmp0:0000000140005A19 C0 C0 05               rol     al, 5 ; 2/3 transformations...</span><br><span class="line">.vmp0:0000000140005A26 FE C0                  inc     al 3/3 transformations...</span><br><span class="line">.vmp0:0000000140005A2F 30 C3                  xor     bl, al ; update rolling key...</span><br></pre></td></tr></table></figure>

<p>上面这段代码对第一个操作数进行解密，这个操作数总是指令操作码。这段代码是calc_jmp例程的一部分，但是对于任何第二个操作数，转换格式都是一样的。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/4.png"></p>
<h2 id="VM-Handlers-规格"><a href="#VM-Handlers-规格" class="headerlink" title="VM Handlers - 规格"></a>VM Handlers - 规格</h2><p>VM handlers包含执行虚拟指令的本地代码。每个 VMProtect 2 二进制文件都有一个 vm handler表，这是一个 256 个 QWORD 的数组。每个条目都包含一个加密的相对虚拟地址，指向相应的vm handler。有许多虚拟指令的变体，如不同大小的即时值以及符号和零扩展值。本节将介绍一些虚拟指令的例子，以及在尝试解析vm handler时必须注意的一些关键信息。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/5.png"></p>
<p>处理即时值的vm handler程序从RSI中获取加密的即时值。然后对这个加密的即时值进行传统的五次转换。转换格式与calc_jmp转换相同。第一个转换应用于加密的即时值，滚动解密密钥是操作的来源。然后，三个转换直接应用于加密的即时值，这将完全解密该值。最后，除了目标和源操作数互换外，滚动解密密钥通过第一次转换进行更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:00000001400076D2 48 8B 06               mov     rax, [rsi] ; fetch immediate value...</span><br><span class="line">.vmp0:00000001400076D9 48 31 D8               xor     rax, rbx ; rolling key transformation...</span><br><span class="line">.vmp0:00000001400076DE 48 C1 C0 1D            rol     rax, 1Dh ; 1/3 transformations...</span><br><span class="line">.vmp0:0000000140007700 48 0F C8               bswap   rax ; 2/3 transformations...</span><br><span class="line">.vmp0:000000014000770F 48 C1 C0 30            rol     rax, 30h ; 3/3 transformations...</span><br><span class="line">.vmp0:0000000140007714 48 31 C3               xor     rbx, rax ; update rolling key...</span><br></pre></td></tr></table></figure>

<p>还要注意的是，vm handlers会受到不透明的分支以及死库混淆的影响。</p>
<h3 id="LCONST-在堆栈中加载常量值"><a href="#LCONST-在堆栈中加载常量值" class="headerlink" title="LCONST - 在堆栈中加载常量值"></a>LCONST - 在堆栈中加载常量值</h3><p>最具代表性的虚拟机指令之一是LCONST。这条虚拟指令将一个常量值从虚拟指令的第二个操作数加载到堆栈中。</p>
<h4 id="LCONSTQ-加载常数QWORD"><a href="#LCONSTQ-加载常数QWORD" class="headerlink" title="LCONSTQ - 加载常数QWORD"></a>LCONSTQ - 加载常数QWORD</h4><p>这是LCONSTQ VM handler的反混淆视图。你可以看到这个VM handler从VIP（RSI）中读取虚拟指令的第二个操作数。然后它解密了这个即时值并推进了VIP。解密后的立即值被放到VSP上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, [rsi]</span><br><span class="line">xor     rax, rbx ; transformation</span><br><span class="line">bswap   rax ; transformation</span><br><span class="line">lea     rsi, [rsi+8] ; advance VIP…</span><br><span class="line">rol     rax, 0Ch ; transformation</span><br><span class="line">inc     rax ; transformation</span><br><span class="line">xor     rbx, rax ; transformation (update rolling decrypt key)</span><br><span class="line">sub     rbp, 8</span><br><span class="line">mov     [rbp+0], rax</span><br></pre></td></tr></table></figure>

<h4 id="LCONSTCDQE-加载常数DWORD符号扩展到一个QWORD"><a href="#LCONSTCDQE-加载常数DWORD符号扩展到一个QWORD" class="headerlink" title="LCONSTCDQE - 加载常数DWORD符号扩展到一个QWORD"></a>LCONSTCDQE - 加载常数DWORD符号扩展到一个QWORD</h4><p>这条虚拟指令从RSI加载一个DWORD大小的操作数，对其进行解密，并将其扩展为一个QWORD，最后将其放在虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [rsi]</span><br><span class="line">xor     eax, ebx</span><br><span class="line">xor     eax, 32B63802h</span><br><span class="line">dec     eax</span><br><span class="line">lea     rsi, [rsi+4] ; advance VIP</span><br><span class="line">xor     eax, 7E4087EEh</span><br><span class="line"></span><br><span class="line">; look below for details on this...</span><br><span class="line">push    rbx</span><br><span class="line">xor     [rsp], eax</span><br><span class="line">pop     rbx</span><br><span class="line"></span><br><span class="line">cdqe ; sign extend EAX to RAX…</span><br><span class="line">sub     rbp, 8</span><br><span class="line">mov     [rbp+0], rax</span><br></pre></td></tr></table></figure>

<p>注意，这个最后的vm handler通过把值放在栈上然后应用转换来更新滚动解密密钥。这是在解析这些vm handler时可能会引起重大问题的东西。幸运的是，有一个非常简单的技巧来处理这个问题，永远记住应用于滚动密钥的转换与第一个转换是一样的。在上面的例子中，它是一个简单的XOR。</p>
<h4 id="LCONSTCBW-加载常数字节转换为字"><a href="#LCONSTCBW-加载常数字节转换为字" class="headerlink" title="LCONSTCBW - 加载常数字节转换为字"></a>LCONSTCBW - 加载常数字节转换为字</h4><p>LCONSTCBW从RSI加载一个常数字节值，对其进行解密，并将结果扩展为一个WORD值。这个解密的值然后被放在虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">movzx eax, byte ptr [rsi]</span><br><span class="line">add al, bl</span><br><span class="line">inc al</span><br><span class="line">neg al</span><br><span class="line">ror al, 0x06</span><br><span class="line">add bl, al</span><br><span class="line">mov ax, [rax+rdi*1]</span><br><span class="line">sub rbp, 0x02</span><br><span class="line">inc rsi</span><br><span class="line">mov [rbp], ax</span><br></pre></td></tr></table></figure>

<h4 id="LCONSTCWDE-加载常数字转换为DWORD"><a href="#LCONSTCWDE-加载常数字转换为DWORD" class="headerlink" title="LCONSTCWDE - 加载常数字转换为DWORD"></a>LCONSTCWDE - 加载常数字转换为DWORD</h4><p>LCONSTCWDE从RSI加载一个常数字，对其进行解密，并将其符号扩展为一个DWORD。最后，结果值被放在虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [rsi]</span><br><span class="line">add rsi, 0x02</span><br><span class="line">xor ax, bx</span><br><span class="line">rol ax, 0x0E</span><br><span class="line">xor ax, 0xA808</span><br><span class="line">neg ax</span><br><span class="line">xor bx, ax</span><br><span class="line">cwde</span><br><span class="line">sub rbp, 0x04</span><br><span class="line">mov [rbp], eax</span><br></pre></td></tr></table></figure>

<h4 id="LCONSTDW-加载常数DWORD"><a href="#LCONSTDW-加载常数DWORD" class="headerlink" title="LCONSTDW - 加载常数DWORD"></a>LCONSTDW - 加载常数DWORD</h4><p>LCONSTDW从RSI加载一个常数字，对其进行解密，最后将结果放在虚拟栈上。还要注意，在下面的例子中，VIP是向后推进的。你可以在操作数的取值中看到这一点，因为它在取消引用之前从RSI中减去了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rsi-0x04]</span><br><span class="line">bswap eax</span><br><span class="line">add eax, ebx</span><br><span class="line">dec eax</span><br><span class="line">neg eax</span><br><span class="line">xor eax, 0x2FFD187C</span><br><span class="line">push rbx</span><br><span class="line">add [rsp], eax</span><br><span class="line">pop rbx</span><br><span class="line">sub rbp, 0x04</span><br><span class="line">mov [rbp], eax</span><br><span class="line">add rsi, 0xFFFFFFFFFFFFFFFC</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="LREG-在堆栈中加载Scratch寄存器的值"><a href="#LREG-在堆栈中加载Scratch寄存器的值" class="headerlink" title="LREG - 在堆栈中加载Scratch寄存器的值"></a>LREG - 在堆栈中加载Scratch寄存器的值</h3><p>让我们来看看另一个VM handler，这个程序的名字是LREG。就像LCONST一样，这条指令有很多变体，特别是针对不同的大小。LREG也将出现在每一个二进制文件中，因为它在虚拟机内部被用来将寄存器值加载到Scratch寄存器中。稍后会有更多关于这个的内容。</p>
<h4 id="LREGQ-加载Scratch寄存器QWORD"><a href="#LREGQ-加载Scratch寄存器QWORD" class="headerlink" title="LREGQ - 加载Scratch寄存器QWORD"></a>LREGQ - 加载Scratch寄存器QWORD</h4><p>LREGQ有一个字节的即时值。这就是Scratch寄存器的索引。一个指向Scratch寄存器的指针总是被加载到RDI中。正如上面多次描述的那样，总共有五个变换应用于即时值，以解密它。第一个转换来自于滚动解密密钥，接着是三个直接应用于即时值的转换，对其进行完全解密。最后，滚动解密密钥被更新，以解密后的即时值为源，对其应用第一次转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov     al, [rsi]</span><br><span class="line">sub     al, bl</span><br><span class="line">ror     al, 2</span><br><span class="line">not     al</span><br><span class="line">inc     al</span><br><span class="line">sub     bl, al</span><br><span class="line">mov     rdx, [rax+rdi]</span><br><span class="line">sub     rbp, 8</span><br><span class="line">mov     [rbp+0], rdx</span><br><span class="line">inc     rsi</span><br></pre></td></tr></table></figure>

<h4 id="LREGDW-加载Scratch寄存器DWORD"><a href="#LREGDW-加载Scratch寄存器DWORD" class="headerlink" title="LREGDW - 加载Scratch寄存器DWORD"></a>LREGDW - 加载Scratch寄存器DWORD</h4><p>LREGDW是LREG的一个变体，它将一个DWORD从一个Scratch寄存器加载到堆栈中。它有两个操作数，第二个是代表scratch寄存器索引的单字节。下面的代码片断是LREGDW的一个解密视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     al, [rsi]</span><br><span class="line">sub     al, bl</span><br><span class="line">add     al, 97h</span><br><span class="line">ror     al, 1</span><br><span class="line">neg     al</span><br><span class="line">sub     bl, al</span><br><span class="line">mov     edx, [rax+rdi]</span><br><span class="line">sub     rbp, 4</span><br><span class="line">mov     [rbp+0], edx</span><br></pre></td></tr></table></figure>

<h3 id="SREG-设置Scratch寄存器值"><a href="#SREG-设置Scratch寄存器值" class="headerlink" title="SREG - 设置Scratch寄存器值"></a>SREG - 设置Scratch寄存器值</h3><p>另一条标志性的虚拟指令是SREG，它在每个二进制文件中都有。这条指令有许多变体，它们将Scratch寄存器设置为某些大小的值。这条虚拟指令有两个操作数，第二个操作数是一个包含scratch寄存器索引的单字节即时值。</p>
<h4 id="SREGQ-设置Scratch寄存器值QWORD"><a href="#SREGQ-设置Scratch寄存器值QWORD" class="headerlink" title="SREGQ - 设置Scratch寄存器值QWORD"></a>SREGQ - 设置Scratch寄存器值QWORD</h4><p>SREGQ在虚拟堆栈的顶部用一个QWORD的值来设置一个虚拟Scratch寄存器。这条虚拟指令由两个操作数组成，第二个操作数是一个代表虚拟Scratch寄存器的单字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movzx   eax, byte ptr [rsi]</span><br><span class="line">sub     al, bl</span><br><span class="line">ror     al, 2</span><br><span class="line">not     al</span><br><span class="line">inc     al</span><br><span class="line">sub     bl, al</span><br><span class="line">mov     rdx, [rbp+0]</span><br><span class="line">add     rbp, 8</span><br><span class="line">mov     [rax+rdi], rdx</span><br></pre></td></tr></table></figure>

<h4 id="SREGDW-设置Scratch寄存器值DWORD"><a href="#SREGDW-设置Scratch寄存器值DWORD" class="headerlink" title="SREGDW - 设置Scratch寄存器值DWORD"></a>SREGDW - 设置Scratch寄存器值DWORD</h4><p>SREGDW在虚拟堆栈的顶部用一个DWORD值设置一个虚拟Scratch寄存器。这条虚拟指令由两个操作数组成，第二个操作数是一个代表虚拟Scratch寄存器的单字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">movzx eax, byte ptr [rsi-0x01]</span><br><span class="line">xor al, bl</span><br><span class="line">inc al</span><br><span class="line">ror al, 0x02</span><br><span class="line">add al, 0xDE</span><br><span class="line">xor bl, al</span><br><span class="line">lea rsi, [rsi-0x01]</span><br><span class="line">mov dx, [rbp]</span><br><span class="line">add rbp, 0x02</span><br><span class="line">mov [rax+rdi*1], dx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SREGW-设置Scratch寄存器值WORD"><a href="#SREGW-设置Scratch寄存器值WORD" class="headerlink" title="SREGW - 设置Scratch寄存器值WORD"></a>SREGW - 设置Scratch寄存器值WORD</h4><p>SREGW从虚拟堆栈的顶部用一个WORD值设置一个虚拟的Scratch寄存器。这条虚拟指令由两个操作数组成，第二个操作数是一个代表虚拟Scratch寄存器的单字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">movzx eax, byte ptr [rsi-0x01]</span><br><span class="line">sub al, bl</span><br><span class="line">ror al, 0x06</span><br><span class="line">neg al</span><br><span class="line">rol al, 0x02</span><br><span class="line">sub bl, al</span><br><span class="line">mov edx, [rbp]</span><br><span class="line">add rbp, 0x04</span><br><span class="line">dec rsi</span><br><span class="line">mov [rax+rdi*1], edx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SREGB-设置Scratch寄存器的字节值"><a href="#SREGB-设置Scratch寄存器的字节值" class="headerlink" title="SREGB - 设置Scratch寄存器的字节值"></a>SREGB - 设置Scratch寄存器的字节值</h4><p>SREGB在虚拟堆栈的顶部设置一个具有BYTE值的虚拟Scratch寄存器。这条虚拟指令由两个操作数组成，第二个操作数是一个代表虚拟Scratch寄存器的单字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov al, [rsi-0x01]</span><br><span class="line">xor al, bl</span><br><span class="line">not al</span><br><span class="line">xor al, 0x10</span><br><span class="line">neg al</span><br><span class="line">xor bl, al</span><br><span class="line">sub rsi, 0x01</span><br><span class="line">mov dx, [rbp]</span><br><span class="line">add rbp, 0x02</span><br><span class="line">mov [rax+rdi*1], dl</span><br></pre></td></tr></table></figure>

<h3 id="ADD-两个值相加"><a href="#ADD-两个值相加" class="headerlink" title="ADD - 两个值相加"></a>ADD - 两个值相加</h3><p>虚拟ADD指令将堆栈中的两个值相加，并将结果存储在堆栈的第二个值位置。由于ADD指令改变了RFLAGS，所以RFLAGS被推到了堆栈上。</p>
<h4 id="ADDQ-两个QWORD值相加"><a href="#ADDQ-两个QWORD值相加" class="headerlink" title="ADDQ - 两个QWORD值相加"></a>ADDQ - 两个QWORD值相加</h4><p>ADDQ添加两个存储在虚拟堆栈顶部的QWORD值。RFLAGS也被推入堆栈，因为本地ADD指令改变了标志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, [rbp+0]</span><br><span class="line">add     [rbp+8], rax</span><br><span class="line">pushfq</span><br><span class="line">pop     qword ptr [rbp+0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ADDW-两个WORDS值相加"><a href="#ADDW-两个WORDS值相加" class="headerlink" title="ADDW - 两个WORDS值相加"></a>ADDW - 两个WORDS值相加</h4><p>ADDW添加两个存储在虚拟堆栈顶部的WORD值。RFLAGS也被推入堆栈，因为本地ADD指令改变了标志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [rbp]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">add [rbp+0x08], ax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ADDB-两个字节的值相加"><a href="#ADDB-两个字节的值相加" class="headerlink" title="ADDB - 两个字节的值相加"></a>ADDB - 两个字节的值相加</h4><p>ADDB添加两个存储在虚拟堆栈顶部的BYTE值。RFLAGS也被推入堆栈，因为本地ADD指令改变了标志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al, [rbp]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">add [rbp+0x08], al</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h3 id="MUL-无符号乘法"><a href="#MUL-无符号乘法" class="headerlink" title="MUL - 无符号乘法"></a>MUL - 无符号乘法</h3><p>虚拟MUL指令将存储在堆栈中的两个值相乘。这些vm处理程序使用本地MUL指令，另外RFLAGS被推入堆栈。最后，它是一条单操作数指令，这意味着没有与该指令相关的即时值。</p>
<h4 id="MULQ-QWORD的无符号乘法"><a href="#MULQ-QWORD的无符号乘法" class="headerlink" title="MULQ - QWORD的无符号乘法"></a>MULQ - QWORD的无符号乘法</h4><p>MULQ将两个QWORD值相乘，结果存储在VSP+24的堆栈中，另外RFLAGS被推到堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp+0x08]</span><br><span class="line">sub rbp, 0x08</span><br><span class="line">mul rdx</span><br><span class="line">mov [rbp+0x08], rdx</span><br><span class="line">mov [rbp+0x10], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DIV-无符号除法"><a href="#DIV-无符号除法" class="headerlink" title="DIV - 无符号除法"></a>DIV - 无符号除法</h3><p>虚拟DIV指令使用本地DIV指令，除法中使用的顶级操作数位于虚拟堆栈的顶部。这是一条单操作数的虚拟指令，因此没有即时值。RFLAGS也被推入堆栈，因为本地DIV指令也可以RFLAGS。</p>
<h4 id="DIVQ-QWORD的无符号除法"><a href="#DIVQ-QWORD的无符号除法" class="headerlink" title="DIVQ - QWORD的无符号除法"></a>DIVQ - QWORD的无符号除法</h4><p>DIVQ对位于虚拟堆栈上的两个QWORD值进行分割。将RFLAGS推到栈上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, [rbp]</span><br><span class="line">mov rax, [rbp+0x08]</span><br><span class="line">div [rbp+0x10]</span><br><span class="line">mov [rbp+0x08], rdx</span><br><span class="line">mov [rbp+0x10], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="READ-读取内存"><a href="#READ-读取内存" class="headerlink" title="READ - 读取内存"></a>READ - 读取内存</h3><p>READ指令可以读取不同大小的内存。这个指令有一个变体，可以读取一个、两个、四个和八个字节。</p>
<h4 id="READQ-读取QWORD"><a href="#READQ-读取QWORD" class="headerlink" title="READQ - 读取QWORD"></a>READQ - 读取QWORD</h4><p>READQ从存储在堆栈顶部的地址中读取一个QWORD值。这条虚拟指令有时似乎有一个段预置在上面。然而并不是所有的READQ vm处理程序都有这个ss与之相关。现在QWORD值被存储在虚拟堆栈的顶部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov rax, ss:[rax]</span><br><span class="line">mov [rbp], rax</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="READDW-读取DWORD"><a href="#READDW-读取DWORD" class="headerlink" title="READDW - 读取DWORD"></a>READDW - 读取DWORD</h4><p>READDW从存储在虚拟栈顶的地址中读取一个DWORD值。然后，该DWORD值被放在虚拟堆栈的顶部。下面是READDW的两个例子，一个使用了这个段索引语法，另一个没有使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">add rbp, 0x04</span><br><span class="line">mov eax, [rax]</span><br><span class="line">mov [rbp], eax</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意下面的分段偏移用法与ss…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">add rbp, 0x04</span><br><span class="line">mov eax, ss:[rax]</span><br><span class="line">mov [rbp], eax</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="READW-读取字"><a href="#READW-读取字" class="headerlink" title="READW - 读取字"></a>READW - 读取字</h4><p>READW从存储在虚拟栈顶的地址中读取一个WORD值。然后，该WORD值被放在虚拟栈的顶部。下面是这个vm处理程序使用段索引语法的一个例子，但是请记住，还有一些vm处理程序没有这个段索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">add rbp, 0x06</span><br><span class="line">mov ax, ss:[rax]</span><br><span class="line">mov [rbp], ax</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="WRITE-写入内存"><a href="#WRITE-写入内存" class="headerlink" title="WRITE - 写入内存"></a>WRITE - 写入内存</h3><p>WRITE虚拟指令最多可以向一个地址写入八个字节。这个虚拟指令有四个变体，2的每一个次幂都有一个，包括8。每个vm处理程序也有使用段偏移类型指令编码的版本。然而在长模式下，一些段基地址是零。似乎总是被使用的段是SS段，它的基数为0，因此段基数在这里没有影响，它只是使解析这些vm处理程序更加困难。</p>
<h4 id="WRITEQ-写入内存QWORD"><a href="#WRITEQ-写入内存QWORD" class="headerlink" title="WRITEQ - 写入内存QWORD"></a>WRITEQ - 写入内存QWORD</h4><p>WRITEQ将一个QWORD值写到位于虚拟堆栈顶部的地址。堆栈增加了16个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140005A74 48 8B 45 00            mov     rax, [rbp+0]</span><br><span class="line">.vmp0:0000000140005A82 48 8B 55 08            mov     rdx, [rbp+8]</span><br><span class="line">.vmp0:0000000140005A8A 48 83 C5 10            add     rbp, 10h</span><br><span class="line">.vmp0:00000001400075CF 48 89 10               mov     [rax], rdx</span><br></pre></td></tr></table></figure>

<h4 id="WRITEDW-写入DWORD"><a href="#WRITEDW-写入DWORD" class="headerlink" title="WRITEDW - 写入DWORD"></a>WRITEDW - 写入DWORD</h4><p>WRITEDW将一个DWORD值写到位于虚拟堆栈顶部的地址。堆栈被增加了12个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov edx, [rbp+0x08]</span><br><span class="line">add rbp, 0x0C</span><br><span class="line">mov [rax], edx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意下面的分段偏移ss的用法…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov edx, [rbp+0x08]</span><br><span class="line">add rbp, 0x0C</span><br><span class="line">mov ss:[rax], edx ; note the SS usage here...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="WRITEW-写入WORD"><a href="#WRITEW-写入WORD" class="headerlink" title="WRITEW - 写入WORD"></a>WRITEW - 写入WORD</h4><p>WRITEW虚拟指令将一个WORD值写到位于虚拟堆栈顶部的地址。然后，堆栈被增加10个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov dx, [rbp+0x08]</span><br><span class="line">add rbp, 0x0A</span><br><span class="line">mov ss:[rax], dx</span><br></pre></td></tr></table></figure>

<h4 id="WRITEB-写入字节"><a href="#WRITEB-写入字节" class="headerlink" title="WRITEB - 写入字节"></a>WRITEB - 写入字节</h4><p>WRITEB虚拟指令将一个BYTE值写到位于虚拟堆栈顶部的地址。然后，堆栈被增加10个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov dl, [rbp+0x08]</span><br><span class="line">add rbp, 0x0A</span><br><span class="line">mov ss:[rax], dl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SHL-左移"><a href="#SHL-左移" class="headerlink" title="SHL - 左移"></a>SHL - 左移</h3><p>SHL vm handler将位于堆栈顶部的一个值向左移动若干位。要移位的位数被存储在堆栈上要移位的值的上方。然后将结果和RFLAGS一起放入堆栈。</p>
<h4 id="SHLCBW-左移转换结果为WORD"><a href="#SHLCBW-左移转换结果为WORD" class="headerlink" title="SHLCBW - 左移转换结果为WORD"></a>SHLCBW - 左移转换结果为WORD</h4><p>SHLCBW将一个字节值向左移动，并将结果扩展为一个WORD。RFLAGS被推到堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov     al, [rbp+0]</span><br><span class="line">mov     cl, [rbp+2]</span><br><span class="line">sub     rbp, 6</span><br><span class="line">shl     al, cl</span><br><span class="line">mov     [rbp+8], ax</span><br><span class="line">pushfq</span><br><span class="line">pop     qword ptr [rbp+0]</span><br></pre></td></tr></table></figure>

<h4 id="SHLW-WORD左移"><a href="#SHLW-WORD左移" class="headerlink" title="SHLW - WORD左移"></a>SHLW - WORD左移</h4><p>SHLW将一个WORD值向左移动。RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [rbp]</span><br><span class="line">mov cl, [rbp+0x02]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">shl ax, cl</span><br><span class="line">mov [rbp+0x08], ax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SHLDW-DWORD左移"><a href="#SHLDW-DWORD左移" class="headerlink" title="SHLDW - DWORD左移"></a>SHLDW - DWORD左移</h4><p>SHLDW将一个DWORD向左移动。RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbp]</span><br><span class="line">mov cl, [rbp+0x04]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">shl eax, cl</span><br><span class="line">mov [rbp+0x08], eax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SHLQ-QWORD左移"><a href="#SHLQ-QWORD左移" class="headerlink" title="SHLQ - QWORD左移"></a>SHLQ - QWORD左移</h4><p>SHLQ将一个QWORD向左移动。RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov cl, [rbp+0x08]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">shl rax, cl</span><br><span class="line">mov [rbp+0x08], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="SHLD-双精度左移"><a href="#SHLD-双精度左移" class="headerlink" title="SHLD - 双精度左移"></a>SHLD - 双精度左移</h4><p>SHLD虚拟指令使用本地指令SHLD将一个值向左移动。然后，结果被放到堆栈和RFLAGS中。这条指令有一个变体，用于一个、两个、四个和八个字节的移位。</p>
<h5 id="SHLDQ-向左移动双精度QWORD"><a href="#SHLDQ-向左移动双精度QWORD" class="headerlink" title="SHLDQ - 向左移动双精度QWORD"></a>SHLDQ - 向左移动双精度QWORD</h5><p>SHLDQ以双精度将一个QWORD向左移位。然后，结果被放到虚拟堆栈中，RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov rdx, [rbp+0x08]</span><br><span class="line">mov cl, [rbp+0x10]</span><br><span class="line">add rbp, 0x02</span><br><span class="line">shld rax, rdx, cl</span><br><span class="line">mov [rbp+0x08], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="SHLDDW-双精度DWORD左移"><a href="#SHLDDW-双精度DWORD左移" class="headerlink" title="SHLDDW - 双精度DWORD左移"></a>SHLDDW - 双精度DWORD左移</h4><p>SHLDDW虚拟指令以双精度将一个DWORD值向左移动。其结果被推入虚拟堆栈以及RFLAGS。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbp]</span><br><span class="line">mov edx, [rbp+0x04]</span><br><span class="line">mov cl, [rbp+0x08]</span><br><span class="line">sub rbp, 0x02</span><br><span class="line">shld eax, edx, cl</span><br><span class="line">mov [rbp+0x08], eax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h3 id="SHR-右移"><a href="#SHR-右移" class="headerlink" title="SHR - 右移"></a>SHR - 右移</h3><p>SHR指令是对SHL的补充，这条虚拟指令改变了RFLAGS，因此执行这条虚拟指令后，RFLAGS值将在堆栈的顶部。</p>
<h4 id="SHRQ-右移QWORD"><a href="#SHRQ-右移QWORD" class="headerlink" title="SHRQ - 右移QWORD"></a>SHRQ - 右移QWORD</h4><p>SHRQ将一个QWORD值向右移动。其结果和RFLAGS一样被放到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov cl, [rbp+0x08]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">shr rax, cl</span><br><span class="line">mov [rbp+0x08], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="SHRD-双精度右移"><a href="#SHRD-双精度右移" class="headerlink" title="SHRD - 双精度右移"></a>SHRD - 双精度右移</h4><p>SHRD虚拟指令以双精度将一个值向右移动。这条指令有一个变体，用于一个、两个、四个和八个字节的移位。这条虚拟指令的结论是RFLAGS被推到虚拟堆栈中。</p>
<h4 id="SHRDQ-双精度右移QWORD"><a href="#SHRDQ-双精度右移QWORD" class="headerlink" title="SHRDQ - 双精度右移QWORD"></a>SHRDQ - 双精度右移QWORD</h4><p>SHRDQ以双精度将一个QWORD值向右移动。其结果被放到虚拟堆栈中。然后RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">mov rdx, [rbp+0x08]</span><br><span class="line">mov cl, [rbp+0x10]</span><br><span class="line">add rbp, 0x02</span><br><span class="line">shrd rax, rdx, cl</span><br><span class="line">mov [rbp+0x08], rax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="SHRDDW-双精度右移DWORD"><a href="#SHRDDW-双精度右移DWORD" class="headerlink" title="SHRDDW - 双精度右移DWORD"></a>SHRDDW - 双精度右移DWORD</h4><p>SHRDDW以双精度将一个DWORD值向右移动。其结果被放到虚拟堆栈中。然后RFLAGS被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [rbp]</span><br><span class="line">mov edx, [rbp+0x04]</span><br><span class="line">mov cl, [rbp+0x08]</span><br><span class="line">sub rbp, 0x02</span><br><span class="line">shrd eax, edx, cl</span><br><span class="line">mov [rbp+0x08], eax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h3 id="NAND-Not-Then-And"><a href="#NAND-Not-Then-And" class="headerlink" title="NAND - Not Then And"></a>NAND - Not Then And</h3><p>NAND指令包括对堆栈顶部的数值应用一个Not，然后将这个Not的结果以比特的方式并入堆栈的下一个数值。and指令改变了RFLAGS，因此，RFLAGS将被推到虚拟堆栈中。</p>
<h4 id="NANDW-不是然后和WORD的"><a href="#NANDW-不是然后和WORD的" class="headerlink" title="NANDW - 不是然后和WORD的"></a>NANDW - 不是然后和WORD的</h4><p>NANDW将两个WORD值进行NOT处理，然后将它们进行位操作并在一起。然后RFLAGs被推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">not dword ptr [rbp]</span><br><span class="line">mov ax, [rbp]</span><br><span class="line">sub rbp, 0x06</span><br><span class="line">and [rbp+0x08], ax</span><br><span class="line">pushfq</span><br><span class="line">pop [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="READCR3-读取控制寄存器3"><a href="#READCR3-读取控制寄存器3" class="headerlink" title="READCR3 - 读取控制寄存器3"></a>READCR3 - 读取控制寄存器3</h4><p>READCR3虚拟指令是一个围绕本地mov寄存器cr3的封装vm处理程序。这条指令将把CR3的值放到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, cr3</span><br><span class="line">sub rbp, 0x08</span><br><span class="line">mov [rbp], rax</span><br></pre></td></tr></table></figure>

<h4 id="WRITECR3-写控制寄存器3"><a href="#WRITECR3-写控制寄存器3" class="headerlink" title="WRITECR3 - 写控制寄存器3"></a>WRITECR3 - 写控制寄存器3</h4><p>WRITECR3虚拟指令是一个围绕本地mov cr3, reg的封装vm处理程序。这条指令将把一个值放入CR3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rbp]</span><br><span class="line">add rbp, 0x08</span><br><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>

<h3 id="PUSHVSP-Push虚拟堆栈指针"><a href="#PUSHVSP-Push虚拟堆栈指针" class="headerlink" title="PUSHVSP - Push虚拟堆栈指针"></a>PUSHVSP - Push虚拟堆栈指针</h3><p>PUSHVSP虚拟指令将本地寄存器RBP中的值推到虚拟堆栈中。这条指令有一个变体，用于1、2、4和8个字节。</p>
<h4 id="PUSHVSPQ-Push虚拟堆栈指针QWORD"><a href="#PUSHVSPQ-Push虚拟堆栈指针QWORD" class="headerlink" title="PUSHVSPQ - Push虚拟堆栈指针QWORD"></a>PUSHVSPQ - Push虚拟堆栈指针QWORD</h4><p>PUSHVSPQ将虚拟堆栈指针的整个值推到虚拟堆栈上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rbp</span><br><span class="line">sub rbp, 0x08</span><br><span class="line">mov [rbp], rax</span><br></pre></td></tr></table></figure>

<h4 id="PUSHVSPDW-推送虚拟栈指针DWORD"><a href="#PUSHVSPDW-推送虚拟栈指针DWORD" class="headerlink" title="PUSHVSPDW - 推送虚拟栈指针DWORD"></a>PUSHVSPDW - 推送虚拟栈指针DWORD</h4><p>PUSHVSPDW将虚拟堆栈指针的底部四个字节推到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebp</span><br><span class="line">sub rbp, 0x04</span><br><span class="line">mov [rbp], eax</span><br></pre></td></tr></table></figure>

<h4 id="PUSVSPW-推送虚拟堆栈指针的WORD值"><a href="#PUSVSPW-推送虚拟堆栈指针的WORD值" class="headerlink" title="PUSVSPW - 推送虚拟堆栈指针的WORD值"></a>PUSVSPW - 推送虚拟堆栈指针的WORD值</h4><p>PUSVSPW将虚拟堆栈指针的底部WORD值推送到虚拟堆栈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebp</span><br><span class="line">sub rbp, 0x02</span><br><span class="line">mov [rbp], ax</span><br></pre></td></tr></table></figure>

<h3 id="LVSP-加载虚拟堆栈指针"><a href="#LVSP-加载虚拟堆栈指针" class="headerlink" title="LVSP - 加载虚拟堆栈指针"></a>LVSP - 加载虚拟堆栈指针</h3><p>这条虚拟指令用堆栈顶部的值加载虚拟堆栈指针寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rbp, [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="LVSPW-加载虚拟堆栈指针字"><a href="#LVSPW-加载虚拟堆栈指针字" class="headerlink" title="LVSPW - 加载虚拟堆栈指针字"></a>LVSPW - 加载虚拟堆栈指针字</h4><p>这条虚拟指令用堆栈顶部的WORD值加载虚拟堆栈指针寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov bp, [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="LVSPDW-加载虚拟堆栈指针DWORD"><a href="#LVSPDW-加载虚拟堆栈指针DWORD" class="headerlink" title="LVSPDW - 加载虚拟堆栈指针DWORD"></a>LVSPDW - 加载虚拟堆栈指针DWORD</h4><p>这条虚拟指令用栈顶的DWORD值加载虚拟堆栈指针寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ebp, [rbp]</span><br></pre></td></tr></table></figure>

<h4 id="LRFLAGS-加载RFLAGS"><a href="#LRFLAGS-加载RFLAGS" class="headerlink" title="LRFLAGS - 加载RFLAGS"></a>LRFLAGS - 加载RFLAGS</h4><p>这条虚拟指令用堆栈顶部的QWORD值加载本地标志寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push [rbp]</span><br><span class="line">add rbp, 0x08</span><br><span class="line">popfq</span><br></pre></td></tr></table></figure>

<h3 id="JMP-虚拟跳转指令"><a href="#JMP-虚拟跳转指令" class="headerlink" title="JMP - 虚拟跳转指令"></a>JMP - 虚拟跳转指令</h3><p>虚拟JMP指令改变RSI寄存器，指向一组新的虚拟指令。堆栈顶部的值是RVA从模块基础到虚拟指令的低32位。然后这个值被加到PE文件的可选头中找到的图像基值的前32位。然后，基址被加到这个值上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov esi, [rbp]</span><br><span class="line">add rbp, 0x08</span><br><span class="line">lea r12, [0x0000000000048F29]</span><br><span class="line">mov rax, 0x00 ; image base bytes above 32bits...</span><br><span class="line">add rsi, rax</span><br><span class="line">mov rbx, rsi ; update decrypt key</span><br><span class="line">add rsi, [rbp] ; add module base address</span><br></pre></td></tr></table></figure>

<h3 id="CALL-虚拟调用指令"><a href="#CALL-虚拟调用指令" class="headerlink" title="CALL - 虚拟调用指令"></a>CALL - 虚拟调用指令</h3><p>虚拟调用指令获取虚拟堆栈顶部的一个地址，然后调用它。RDX被用来保存地址，所以你只能用它来真正调用具有单一参数的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, [rbp]</span><br><span class="line">add rbp, 0x08</span><br><span class="line">call rdx</span><br></pre></td></tr></table></figure>

<h1 id="重要的虚拟机签名-静态分析"><a href="#重要的虚拟机签名-静态分析" class="headerlink" title="重要的虚拟机签名 - 静态分析"></a>重要的虚拟机签名 - 静态分析</h1><p>现在，VMProtect 2 的虚拟机架构已被记录下来，我们可以思考重要的签名。此外，VMProtect 2 产生的混淆也可以用相当简单的技术处理。这可以使解析vm_entry例程变得微不足道。vm_entry没有合法的JCC，所以每次遇到JCC时，我们可以简单地跟踪它，从指令流中删除JCC，然后一旦遇到JMP RCX&#x2F;RDX就停止。我们可以通过跟踪指令如何被Zydis使用，特别是跟踪指令的目标寄存器的读写依赖性，来删除大部分deadstore。最后，有了清理过的vm_entry，我们现在可以遍历所有的指令，找到vm处理程序，解密vm处理程序表项所需的转换，最后是解密跳转到vm_entry之前推到堆栈的虚拟指令的相对虚拟地址所需的转换。</p>
<h2 id="定位虚拟机处理程序表"><a href="#定位虚拟机处理程序表" class="headerlink" title="定位虚拟机处理程序表"></a>定位虚拟机处理程序表</h2><p>最好的，也是最知名的签名之一是LEA r12，vm_handlers。这条指令位于vm_entry代码段内，将vm处理程序表的线性虚拟地址加载到R12中。使用Zydis，我们可以很容易地找到并解析这个LEA，从而自己找到vm handler表的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">uintptr_t</span>* vm::handler::table::<span class="built_in">get</span>(<span class="type">const</span> <span class="type">zydis_routine_t</span>&amp; vm_entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> result = std::<span class="built_in">find_if</span>(</span><br><span class="line">        vm_entry.<span class="built_in">begin</span>(), vm_entry.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> instr = &amp;instr_data.instr;</span><br><span class="line">            <span class="comment">// lea r12, vm_handlers... (always r12)...</span></span><br><span class="line">            <span class="keyword">if</span> (instr-&gt;mnemonic == ZYDIS_MNEMONIC_LEA &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">0</span>].type == ZYDIS_OPERAND_TYPE_REGISTER &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">0</span>].reg.value == ZYDIS_REGISTER_R12 &amp;&amp;</span><br><span class="line">                !instr-&gt;raw.sib.base) <span class="comment">// no register used for the sib base...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == vm_entry.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">uintptr_t</span> ptr = <span class="number">0u</span>;</span><br><span class="line">    <span class="built_in">ZydisCalcAbsoluteAddress</span>(&amp;result-&gt;instr,</span><br><span class="line">        &amp;result-&gt;instr.operands[<span class="number">1</span>], result-&gt;addr, &amp;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;std::<span class="type">uintptr_t</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述Zydis例程将静态地定位虚拟机处理表的地址。它只需要一个ZydisDecodedInstructions的向量，vm_entry例程中的每个指令都有一个。我的实现（vmprofiler）将首先对vm_entry进行解密，然后再传递这个向量。</p>
<h2 id="定位虚拟机处理程序表条目解密"><a href="#定位虚拟机处理程序表条目解密" class="headerlink" title="定位虚拟机处理程序表条目解密"></a>定位虚拟机处理程序表条目解密</h2><p>你可以很容易地以编程方式确定对虚拟机处理程序表条目应用了什么转换，首先找到从该表获取条目的指令。这条指令记录在vm_entry部分，它由一条SIB指令组成，RDX或RCX为目标，R12为基数，RAX为索引，8为比例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140005A41 49 8B 14 C4            mov     rdx, [r12+rax*8]</span><br></pre></td></tr></table></figure>

<p>使用Zydis可以很容易地找到这一点。所要做的就是找到一条以RCX或RDX为目标的SIB mov指令，R12为基数，RAX为索引，最后是8为索引。现在，使用Zydis我们可以找到下一条以RDX或RCX为目标的指令，这条指令将是应用于VM处理表项的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vm::handler::table::<span class="built_in">get_transform</span>(</span><br><span class="line">    <span class="type">const</span> <span class="type">zydis_routine_t</span>&amp; vm_entry, ZydisDecodedInstruction* transform_instr)</span><br><span class="line">&#123;</span><br><span class="line">    ZydisRegister rcx_or_rdx = ZYDIS_REGISTER_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> handler_fetch = std::<span class="built_in">find_if</span>(</span><br><span class="line">        vm_entry.<span class="built_in">begin</span>(), vm_entry.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> instr = &amp;instr_data.instr;</span><br><span class="line">            <span class="keyword">if</span> (instr-&gt;mnemonic == ZYDIS_MNEMONIC_MOV &amp;&amp;</span><br><span class="line">                instr-&gt;operand_count == <span class="number">2</span> &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">1</span>].type == ZYDIS_OPERAND_TYPE_MEMORY &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">1</span>].mem.base == ZYDIS_REGISTER_R12 &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">1</span>].mem.index == ZYDIS_REGISTER_RAX &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">1</span>].mem.scale == <span class="number">8</span> &amp;&amp;</span><br><span class="line">                instr-&gt;operands[<span class="number">0</span>].type == ZYDIS_OPERAND_TYPE_REGISTER &amp;&amp;</span><br><span class="line">                (instr-&gt;operands[<span class="number">0</span>].reg.value == ZYDIS_REGISTER_RDX ||</span><br><span class="line">                    instr-&gt;operands[<span class="number">0</span>].reg.value == ZYDIS_REGISTER_RCX))</span><br><span class="line">            &#123;</span><br><span class="line">                rcx_or_rdx = instr-&gt;operands[<span class="number">0</span>].reg.value;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check to see if we found the fetch instruction and if the next instruction</span></span><br><span class="line">    <span class="comment">// is not the end of the vector...</span></span><br><span class="line">    <span class="keyword">if</span> (handler_fetch == vm_entry.<span class="built_in">end</span>() || ++handler_fetch == vm_entry.<span class="built_in">end</span>() ||</span><br><span class="line">        <span class="comment">// must be RCX or RDX... else something went wrong...</span></span><br><span class="line">        (rcx_or_rdx != ZYDIS_REGISTER_RCX &amp;&amp; rcx_or_rdx != ZYDIS_REGISTER_RDX))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the next instruction that writes to RCX or RDX...</span></span><br><span class="line">    <span class="comment">// the register is determined by the vm handler fetch above...</span></span><br><span class="line">    <span class="keyword">auto</span> handler_transform = std::<span class="built_in">find_if</span>(</span><br><span class="line">        handler_fetch, vm_entry.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instr_data.instr.operands[<span class="number">0</span>].reg.value == rcx_or_rdx &amp;&amp;</span><br><span class="line">                instr_data.instr.operands[<span class="number">0</span>].actions &amp; ZYDIS_OPERAND_ACTION_WRITE)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler_transform == vm_entry.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *transform_instr = handler_transform-&gt;instr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将解析vm_entry例程，并返回为解密虚拟机处理表项所做的转换。在C++中，每个转换操作都可以用lambdas来实现，可以用一个函数编码来返回必须应用的转换的相应lambda例程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140005A41 49 8B 14 C4            mov     rdx, [r12+rax*8]</span><br><span class="line">.vmp0:0000000140005A49 48 81 F2 49 21 3D 7F   xor     rdx, 7F3D2149h</span><br></pre></td></tr></table></figure>

<p>上面的代码等同于下面的C++代码。这将解密vm处理程序条目。为了加密新的数值，必须进行逆向操作。然而对于XOR来说，这只是简单的XOR。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vm::decrypt_handler _decrypt_handler = </span><br><span class="line">    [](std::<span class="type">uint8_t</span> idx) -&gt; std::<span class="type">uint64_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> vm_handlers[idx] ^ <span class="number">0x7F3D2149</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is not the best example as the inverse of XOR is XOR...</span></span><br><span class="line">vm::encrypt_handler _encrypt_handler = </span><br><span class="line">    [](std::<span class="type">uint8_t</span> idx) -&gt; std::<span class="type">uint64_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> vm_handlers[idx] ^ <span class="number">0x7F3D2149</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="处理转换–模板化的Lambdas和Maps"><a href="#处理转换–模板化的Lambdas和Maps" class="headerlink" title="处理转换–模板化的Lambdas和Maps"></a>处理转换–模板化的Lambdas和Maps</h2><p>上述解密和加密处理程序可以通过创建每个转换类型的映射和该指令的C++ lambda再实现来动态生成。此外，还可以创建一个处理动态值的例程，如字节大小。这可以防止每次需要转换时都要创建一个开关案例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> transform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> std::map&lt;ZydisMnemonic, <span class="type">transform_t</span>&lt;T&gt;&gt; transforms =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; ZYDIS_MNEMONIC_ADD, _add&lt;T&gt; &#125;,</span><br><span class="line">        &#123; ZYDIS_MNEMONIC_XOR, _xor&lt;T&gt; &#125;,</span><br><span class="line">        &#123; ZYDIS_MNEMONIC_BSWAP, _bswap&lt;T&gt; &#125;,</span><br><span class="line">        <span class="comment">// SUB, INC, DEC, OR, AND, ETC...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max size of a and b is 64 bits, a and b is then converted to </span></span><br><span class="line">    <span class="comment">// the number of bits in bitsize, the transformation is applied,</span></span><br><span class="line">    <span class="comment">// finally the result is converted back to 64bits...</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">apply</span><span class="params">(std::<span class="type">uint8_t</span> bitsize, ZydisMnemonic op,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::<span class="type">uint64_t</span> a, std::<span class="type">uint64_t</span> b)</span> -&gt; std::<span class="type">uint64_t</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (bitsize)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> transforms&lt;std::<span class="type">uint8_t</span>&gt;[op](a, b);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> transforms&lt;std::<span class="type">uint16_t</span>&gt;[op](a, b);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            <span class="keyword">return</span> transforms&lt;std::<span class="type">uint32_t</span>&gt;[op](a, b);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            <span class="keyword">return</span> transforms&lt;std::<span class="type">uint64_t</span>&gt;[op](a, b);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;invalid bit size...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一小段代码将允许在考虑到溢出的情况下轻松实现C++中的转换。在转换过程中，重视大小是非常重要的，因为如果没有正确的大小，溢出以及滚动和移位都是不正确的。下面的代码是一个例子，说明如何通过在C++中动态地实现转换来解密虚拟指令的操作数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// here for your eyes - better understanding of the code :^)</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">map_t</span> = std::map&lt;transform::type, ZydisDecodedInstruction&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decrypt_operand</span><span class="params">(transform::<span class="type">map_t</span>&amp; transforms, </span></span></span><br><span class="line"><span class="params"><span class="function">    std::<span class="type">uint64_t</span> operand, std::<span class="type">uint64_t</span> rolling_key)</span> -&gt; std::pair&lt;std::<span class="type">uint64_t</span>, std::<span class="type">uint64_t</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> key_decrypt = &amp;transforms[transform::type::rolling_key];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> generic_decrypt_1 = &amp;transforms[transform::type::generic1];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> generic_decrypt_2 = &amp;transforms[transform::type::generic2];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> generic_decrypt_3 = &amp;transforms[transform::type::generic3];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> update_key = &amp;transforms[transform::type::update_key];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply transformation with rolling decrypt key...</span></span><br><span class="line">    operand = transform::<span class="built_in">apply</span>(key_decrypt-&gt;operands[<span class="number">0</span>].size,</span><br><span class="line">        key_decrypt-&gt;mnemonic, operand, rolling_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply three generic transformations...</span></span><br><span class="line">    &#123;</span><br><span class="line">        operand = transform::<span class="built_in">apply</span>(</span><br><span class="line">            generic_decrypt_1-&gt;operands[<span class="number">0</span>].size,</span><br><span class="line">            generic_decrypt_1-&gt;mnemonic, operand, </span><br><span class="line">            <span class="comment">// check to see if this instruction has an IMM...</span></span><br><span class="line">            transform::<span class="built_in">has_imm</span>(generic_decrypt_1) ? </span><br><span class="line">                generic_decrypt_1-&gt;operands[<span class="number">1</span>].imm.value.u : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        operand = transform::<span class="built_in">apply</span>(</span><br><span class="line">            generic_decrypt_2-&gt;operands[<span class="number">0</span>].size,</span><br><span class="line">            generic_decrypt_2-&gt;mnemonic, operand,</span><br><span class="line">            <span class="comment">// check to see if this instruction has an IMM...</span></span><br><span class="line">            transform::<span class="built_in">has_imm</span>(generic_decrypt_2) ?</span><br><span class="line">                generic_decrypt_2-&gt;operands[<span class="number">1</span>].imm.value.u : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        operand = transform::<span class="built_in">apply</span>(</span><br><span class="line">            generic_decrypt_3-&gt;operands[<span class="number">0</span>].size,</span><br><span class="line">            generic_decrypt_3-&gt;mnemonic, operand,</span><br><span class="line">            <span class="comment">// check to see if this instruction has an IMM...</span></span><br><span class="line">            transform::<span class="built_in">has_imm</span>(generic_decrypt_3) ?</span><br><span class="line">                generic_decrypt_3-&gt;operands[<span class="number">1</span>].imm.value.u : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update rolling key...</span></span><br><span class="line">    rolling_key = transform::<span class="built_in">apply</span>(key_decrypt-&gt;operands[<span class="number">0</span>].size,</span><br><span class="line">        key_decrypt-&gt;mnemonic, rolling_key, operand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; operand, rolling_key &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取转换-静态分析继续"><a href="#提取转换-静态分析继续" class="headerlink" title="提取转换 - 静态分析继续"></a>提取转换 - 静态分析继续</h3><p>重新实现转换的能力是很重要的，然而，能够从vm处理程序和calc_jmp中解析出转换是另一个需要自己解决的问题。为了确定转换的位置，我们必须首先确定是否有转换的需要。变换只适用于虚拟指令的操作数。虚拟指令的第一个操作数总是在同一个地方进行转换，这个代码被称为calc_jmp，我在前面解释过。转化的第二个地方是在处理即时值的vm处理程序中发现的。换句话说，如果一条虚拟指令有一个即时值，那么对于这个操作数将有一套独特的转换。即时值是从VIP中读出的（RSI），所以我们可以使用这个关键细节来确定是否有即时值以及即时值的大小。值得注意的是，从VIP中读出的即时值并不总是等于为LCONST等指令在堆栈中分配的解密值的大小。这是因为符号扩展和零扩展的虚拟指令。让我们来看看一个有即时值的虚拟指令的例子。这条虚拟指令被称为LCONSTWSE，代表 “加载大小为word的常量值，但符号扩展为DWORD”。这条虚拟指令的解密vm处理程序看起来像这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140004478 66 0F B7 06            movzx   ax, word ptr [rsi]</span><br><span class="line">.vmp0:0000000140004412 66 29 D8               sub     ax, bx</span><br><span class="line">.vmp0:0000000140004416 66 D1 C0               rol     ax, 1</span><br><span class="line">.vmp0:0000000140004605 66 F7 D8               neg     ax</span><br><span class="line">.vmp0:000000014000460A 66 35 AC 21            xor     ax, 21ACh</span><br><span class="line">.vmp0:000000014000460F 66 29 C3               sub     bx, ax</span><br><span class="line">.vmp0:0000000140004613 98                     cwde</span><br><span class="line">.vmp0:0000000140004618 48 83 ED 04            sub     rbp, 4</span><br><span class="line">.vmp0:0000000140006E4F 89 45 00               mov     [rbp+0], eax</span><br><span class="line">.vmp0:0000000140007E2D 48 8D 76 02            lea     rsi, [rsi+2]</span><br></pre></td></tr></table></figure>

<p>如你所见，有两个字节从VIP中读出。这是第一条指令。这是我们可以在zydis中寻找的东西。任何以RAX为目的，RSI为源的MOVZX、MOVSX或MOV都表明有一个即时值，因此我们知道在指令流中预计有五个转换。然后我们可以搜索一条指令，其中RAX是目标，RBX是源。这将是第一个转换。在上面的例子中，第一条减法指令就是我们要找的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140004412 66 29 D8               sub     ax, bx</span><br></pre></td></tr></table></figure>

<p>接下来我们可以寻找三条对RAX有写入依赖性的指令。这三条指令将是应用于操作数的通用转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140004416 66 D1 C0               rol     ax, 1</span><br><span class="line">.vmp0:0000000140004605 66 F7 D8               neg     ax</span><br><span class="line">.vmp0:000000014000460A 66 35 AC 21            xor     ax, 21ACh</span><br></pre></td></tr></table></figure>

<p>在这一点上，操作数被完全解密了。唯一剩下的是对滚动解密密钥（RBX）进行的一次转换。这最后一次转换更新了滚动解密密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:000000014000460F 66 29 C3               sub     bx, ax</span><br></pre></td></tr></table></figure>

<p>所有这些转换指令现在都可以由C++的lambdas在飞行中重新实现。使用std::find_if对于这些类型的搜索算法非常有用，因为你可以一步步来。首先找到关键的转换，然后找到写给RAX的下三个指令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vm::handler::<span class="built_in">get_transforms</span>(<span class="type">const</span> <span class="type">zydis_routine_t</span>&amp; vm_handler, transform::<span class="type">map_t</span>&amp; transforms)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> imm_fetch = std::<span class="built_in">find_if</span>(</span><br><span class="line">        vm_handler.<span class="built_in">begin</span>(), vm_handler.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mov/movsx/movzx rax/eax/ax/al, [rsi]</span></span><br><span class="line">            <span class="keyword">if</span> (instr_data.instr.operand_count &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                (instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOV ||</span><br><span class="line">                    instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOVSX ||</span><br><span class="line">                    instr_data.instr.mnemonic == ZYDIS_MNEMONIC_MOVZX) &amp;&amp;</span><br><span class="line">                instr_data.instr.operands[<span class="number">0</span>].type == ZYDIS_OPERAND_TYPE_REGISTER &amp;&amp;</span><br><span class="line">                util::reg::<span class="built_in">compare</span>(instr_data.instr.operands[<span class="number">0</span>].reg.value, ZYDIS_REGISTER_RAX) &amp;&amp;</span><br><span class="line">                instr_data.instr.operands[<span class="number">1</span>].type == ZYDIS_OPERAND_TYPE_MEMORY &amp;&amp;</span><br><span class="line">                instr_data.instr.operands[<span class="number">1</span>].mem.base == ZYDIS_REGISTER_RSI)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_fetch == vm_handler.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this finds the first transformation which looks like:</span></span><br><span class="line">    <span class="comment">// transform rax, rbx &lt;--- note these registers can be smaller so we to64 them...</span></span><br><span class="line">    <span class="keyword">auto</span> key_transform = std::<span class="built_in">find_if</span>(imm_fetch, vm_handler.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (util::reg::<span class="built_in">compare</span>(instr_data.instr.operands[<span class="number">0</span>].reg.value, ZYDIS_REGISTER_RAX) &amp;&amp;</span><br><span class="line">                util::reg::<span class="built_in">compare</span>(instr_data.instr.operands[<span class="number">1</span>].reg.value, ZYDIS_REGISTER_RBX))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// last transformation is the same as the first except src and dest are swapped...</span></span><br><span class="line">    transforms[transform::type::rolling_key] = key_transform-&gt;instr;</span><br><span class="line">    <span class="keyword">auto</span> instr_copy = key_transform-&gt;instr;</span><br><span class="line">    instr_copy.operands[<span class="number">0</span>].reg.value = key_transform-&gt;instr.operands[<span class="number">1</span>].reg.value;</span><br><span class="line">    instr_copy.operands[<span class="number">1</span>].reg.value = key_transform-&gt;instr.operands[<span class="number">0</span>].reg.value;</span><br><span class="line">    transforms[transform::type::update_key] = instr_copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_transform == vm_handler.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// three generic transformations...</span></span><br><span class="line">    <span class="keyword">auto</span> generic_transform = key_transform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> idx = <span class="number">0u</span>; idx &lt; <span class="number">3</span>; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        generic_transform = std::<span class="built_in">find_if</span>(++generic_transform, vm_handler.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> <span class="type">zydis_instr_t</span>&amp; instr_data) -&gt; <span class="type">bool</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (util::reg::<span class="built_in">compare</span>(instr_data.instr.operands[<span class="number">0</span>].reg.value, ZYDIS_REGISTER_RAX))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (generic_transform == vm_handler.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        transforms[(transform::type)(idx + <span class="number">1</span>)] = generic_transform-&gt;instr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如你所看到的，除了源操作数和目的操作数互换外，第一个转换与最后一个转换是一样的。VMProtect 2 在应用最后一次转换时有一些创造性的自由，有时会将滚动解密密钥推到堆栈中，应用转换，然后将结果弹回 RBX。这个小但重要的不便可以通过简单地交换ZydisDecodedInstruction变量中的目标和源寄存器来处理，如上面的代码所示。</p>
<h2 id="静态分析的困境-静态分析的结论"><a href="#静态分析的困境-静态分析的结论" class="headerlink" title="静态分析的困境 - 静态分析的结论"></a>静态分析的困境 - 静态分析的结论</h2><p>试图静态分析虚拟指令的困境是，虚拟机内部的分支操作非常难以处理。为了计算一个虚拟JMP的跳转位置，需要进行仿真。我将在不久的将来进行这方面的研究（独角兽）。</p>
<h3 id="vmtracer-追踪虚拟指令"><a href="#vmtracer-追踪虚拟指令" class="headerlink" title="vmtracer - 追踪虚拟指令"></a>vmtracer - 追踪虚拟指令</h3><p>追踪虚拟指令的方法很简单，就是把每一个vm处理程序表的条目修补成一个加密的值，当解密的时候指向一个陷阱处理程序。这将允许对寄存器进行指令间检查，并有可能改变vm处理器的结果。为了很好地利用这一功能，重要的是要了解哪些寄存器包含哪些值。你可以参考这篇文章的 “概述部分”。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/6.png"></p>
<p>在拦截虚拟指令时，首先要记录的重要信息是位于AL的操作码值。记录这个将告诉我们所有执行的虚拟指令。下一个必须被记录的值是位于BL的滚动解密密钥值。这将使vmprofiler能够静态地解密操作数。</p>
<p>既然我们能够做到，在每一条虚拟指令之后记录所有的scratch寄存器是对记录信息的一个重要补充，因为这将描绘出一幅更大的画面，说明哪些值被操纵了。最后，记录虚拟堆栈上的前五个QWORD值是为了提供更多的信息，因为这个虚拟指令集架构是基于堆栈机的。</p>
<p>为了结束这篇文章的动态分析部分，我为这些运行时数据创建了一个小文件格式。该文件格式被称为 “vmp2”，包含所有的运行时日志信息。这个文件格式的结构非常简单，它们被列在下面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> vmp2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">exec_type_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        forward,</span><br><span class="line">        backward</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">version_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        invalid,</span><br><span class="line">        v1 = <span class="number">0x101</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file_header</span></span><br><span class="line">    &#123;</span><br><span class="line">        u32 magic; <span class="comment">// VMP2</span></span><br><span class="line">        u64 epoch_time;</span><br><span class="line">        u64 module_base;</span><br><span class="line">        <span class="type">exec_type_t</span> advancement;</span><br><span class="line">        <span class="type">version_t</span> version;</span><br><span class="line">        u32 entry_count;</span><br><span class="line">        u32 entry_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">entry_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 handler_idx;</span><br><span class="line">        u64 decrypt_key;</span><br><span class="line">        u64 vip;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span></span><br><span class="line">            &#123;</span><br><span class="line">                u64 r15;</span><br><span class="line">                u64 r14;</span><br><span class="line">                u64 r13;</span><br><span class="line">                u64 r12;</span><br><span class="line">                u64 r11;</span><br><span class="line">                u64 r10;</span><br><span class="line">                u64 r9;</span><br><span class="line">                u64 r8;</span><br><span class="line">                u64 rbp;</span><br><span class="line">                u64 rdi;</span><br><span class="line">                u64 rsi;</span><br><span class="line">                u64 rdx;</span><br><span class="line">                u64 rcx;</span><br><span class="line">                u64 rbx;</span><br><span class="line">                u64 rax;</span><br><span class="line">                u64 rflags;</span><br><span class="line">            &#125;;</span><br><span class="line">            u64 raw[<span class="number">16</span>];</span><br><span class="line">        &#125; regs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        &#123;</span><br><span class="line">            u64 qword[<span class="number">0x28</span>];</span><br><span class="line">            u8 raw[<span class="number">0x140</span>];</span><br><span class="line">        &#125; vregs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        &#123;</span><br><span class="line">            u64 qword[<span class="number">0x20</span>];</span><br><span class="line">            u8 raw[<span class="number">0x100</span>];</span><br><span class="line">        &#125; vsp;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vmprofile-cli-使用运行时跟踪的静态分析"><a href="#vmprofile-cli-使用运行时跟踪的静态分析" class="headerlink" title="vmprofile-cli - 使用运行时跟踪的静态分析"></a>vmprofile-cli - 使用运行时跟踪的静态分析</h3><p>如果提供一个 “vmp2”文件，vmprofiler将产生伪虚拟指令，包括即时值以及受影响的scratch寄存器。这绝不是去虚拟化，也不提供多个代码路径的视图，但是它确实提供了一个非常有用的已执行虚拟指令的跟踪。Vmprofiler还可以用来静态地定位vm handler表，并确定使用什么转换来解密这些vm handler条目。</p>
<p>vmprofiler的一个示例输出将产生关于每个vm处理程序的所有信息，包括即时值的位数，虚拟指令的名称，以及应用于即时值的五个转换（如果有即时值）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==========[vm handler LCONSTCBW, imm size = 8]=======</span><br><span class="line">================[vm handler instructions]============</span><br><span class="line">&gt; 0x00007FF65BAE5C2E movzx eax, byte ptr [rsi]</span><br><span class="line">&gt; 0x00007FF65BAE5C82 add al, bl</span><br><span class="line">&gt; 0x00007FF65BAE5C85 add al, 0xD3</span><br><span class="line">&gt; 0x00007FF65BAE6FC7 not al</span><br><span class="line">&gt; 0x00007FF65BAE4D23 inc al</span><br><span class="line">&gt; 0x00007FF65BAE5633 add bl, al</span><br><span class="line">&gt; 0x00007FF65BAE53D5 sub rsi, 0xFFFFFFFFFFFFFFFF</span><br><span class="line">&gt; 0x00007FF65BAE5CD1 sub rbp, 0x02</span><br><span class="line">&gt; 0x00007FF65BAE62F8 mov [rbp], ax</span><br><span class="line">=================[vm handler transforms]=============</span><br><span class="line">add al, bl</span><br><span class="line">add al, 0xD3</span><br><span class="line">not al</span><br><span class="line">inc al</span><br><span class="line">add bl, al</span><br><span class="line">=====================================================</span><br></pre></td></tr></table></figure>

<p>如果有的话，这些转换也会从vm处理程序中提取出来，并可以动态地执行以解密操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; SREGQ 0x0000000000000088 (VSP[0] = 0x00007FF549600000) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; LCONSTDSX 0x000000007D361173 (VSP[0] = 0x0000000000000000) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; ADDQ (VSP[0] = 0x000000007D361173) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; SREGQ 0x0000000000000010 (VSP[0] = 0x0000000000000202) (VSP[1] = 0x000000007D361173)</span><br><span class="line">&gt; SREGQ 0x0000000000000048 (VSP[0] = 0x000000007D361173) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; SREGQ 0x0000000000000000 (VSP[0] = 0x0000000000000000) (VSP[1] = 0x0000000000000100)</span><br><span class="line">&gt; SREGQ 0x0000000000000038 (VSP[0] = 0x0000000000000100) (VSP[1] = 0x00000000000000B8)</span><br><span class="line">&gt; SREGQ 0x0000000000000028 (VSP[0] = 0x00000000000000B8) (VSP[1] = 0x0000000000000246)</span><br><span class="line">&gt; SREGQ 0x00000000000000B8 (VSP[0] = 0x0000000000000246) (VSP[1] = 0x0000000000000100)</span><br><span class="line">&gt; SREGQ 0x0000000000000010 (VSP[0] = 0x0000000000000100) (VSP[1] = 0x000000892D8FDA88)</span><br><span class="line">&gt; SREGQ 0x00000000000000B0 (VSP[0] = 0x000000892D8FDA88) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; SREGQ 0x0000000000000040 (VSP[0] = 0x0000000000000000) (VSP[1] = 0x0000000000000020)</span><br><span class="line">&gt; SREGQ 0x0000000000000030 (VSP[0] = 0x0000000000000020) (VSP[1] = 0x0000000000000000)</span><br><span class="line">&gt; SREGQ 0x0000000000000020 (VSP[0] = 0x0000000000000000) (VSP[1] = 0x2AAAAAAAAAAAAAAB)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<h1 id="显示跟踪信息-vmprofiler-qt"><a href="#显示跟踪信息-vmprofiler-qt" class="headerlink" title="显示跟踪信息 - vmprofiler-qt"></a>显示跟踪信息 - vmprofiler-qt</h1><p>为了显示所有的跟踪信息，如本地寄存器的值、从动寄存器的值和虚拟堆栈的值，我创建了一个非常小的Qt项目，它可以让你在跟踪中一步步的进行。我觉得控制台的限制性太大，而且我也发现很难对需要在控制台显示的内容进行优先排序，因此需要一个GUI。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/7.png"></p>
<h1 id="虚拟机的行为"><a href="#虚拟机的行为" class="headerlink" title="虚拟机的行为"></a>虚拟机的行为</h1><p>在vm_entry例程执行后，所有被推入堆栈的寄存器都被加载到虚拟机的scratch寄存器。这也延伸到了模块基数和RFLAGS，它们也被推入了堆栈。本机寄存器到scratch寄存器的映射不被尊重。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/8.png"></p>
<p>虚拟机架构表现出的另一个行为是，如果一条本地指令没有用vm处理程序实现，那么vmexit将发生，以执行本地指令。在我的VMProtect 2版本中，CPUID没有用vm处理程序实现，所以会发生退出。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/9.png"></p>
<p>在vmexit之前，从零开始的寄存器的值被加载到虚拟堆栈。vmexit虚拟指令将把这些值放回本地寄存器中。你可以看到，从头开始的寄存器和直接在vmentry之后的寄存器是不同的。这是因为就像我之前说的，从头开始的寄存器没有被映射到本地寄存器。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/10.png"></p>
<h1 id="Demo-创建和检查一个虚拟跟踪"><a href="#Demo-创建和检查一个虚拟跟踪" class="headerlink" title="Demo - 创建和检查一个虚拟跟踪"></a>Demo - 创建和检查一个虚拟跟踪</h1><p>在这个Demo中，我将虚拟一个非常简单的二进制文件，它只是执行CPUID，如果支持AVX则返回真，否则返回假。下面显示的是它的汇编代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00007FF776A01000 ; int __fastcall main()</span><br><span class="line">.text:00007FF776A01000                 public main</span><br><span class="line">.text:00007FF776A01000                 push    rbx</span><br><span class="line">.text:00007FF776A01002                 sub     rsp, 10h</span><br><span class="line">.text:00007FF776A01006                 xor     ecx, ecx</span><br><span class="line">.text:00007FF776A01008                 mov     eax, 1</span><br><span class="line">.text:00007FF776A0100D                 cpuid</span><br><span class="line">.text:00007FF776A0100F                 shr     ecx, 1Ch</span><br><span class="line">.text:00007FF776A01012                 and     ecx, 1</span><br><span class="line">.text:00007FF776A01015                 mov     eax, ecx</span><br><span class="line">.text:00007FF776A01017                 add     rsp, 10h</span><br><span class="line">.text:00007FF776A0101B                 pop     rbx</span><br><span class="line">.text:00007FF776A0101C                 retn</span><br><span class="line">.text:00007FF776A0101C main            endp</span><br></pre></td></tr></table></figure>

<p>在保护这段代码时，为了简化演示，我选择了不使用打包。我使用了 “Ultra “设置来保护二进制文件，这只是混淆+虚拟化。看一下输出文件的PE头，我们可以看到入口点RVA是0x1000，图像基数是0x140000000。我们现在可以把这些信息给vmprofiler-cli，它应该给我们提供虚拟机处理表RVA以及所有虚拟机处理信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; vmprofiler-cli.exe --vmpbin vmptest.vmp.exe --vmentry 0x1000 --imagebase 0x140000000</span><br><span class="line"></span><br><span class="line">&gt; 0x00007FF670F2822C push 0xFFFFFFFF890001FA</span><br><span class="line">&gt; 0x00007FF670F27FC9 push 0x45D3BF1F</span><br><span class="line">&gt; 0x00007FF670F248E4 push r13</span><br><span class="line">&gt; 0x00007FF670F24690 push rsi</span><br><span class="line">&gt; 0x00007FF670F24E53 push r14</span><br><span class="line">&gt; 0x00007FF670F274FB push rcx</span><br><span class="line">&gt; 0x00007FF670F2607C push rsp</span><br><span class="line">&gt; 0x00007FF670F24926 pushfq</span><br><span class="line">&gt; 0x00007FF670F24DC2 push rbp</span><br><span class="line">&gt; 0x00007FF670F25C8C push r12</span><br><span class="line">&gt; 0x00007FF670F252AC push r10</span><br><span class="line">&gt; 0x00007FF670F251A5 push r9</span><br><span class="line">&gt; 0x00007FF670F25189 push rdx</span><br><span class="line">&gt; 0x00007FF670F27D5F push r8</span><br><span class="line">&gt; 0x00007FF670F24505 push rdi</span><br><span class="line">&gt; 0x00007FF670F24745 push r11</span><br><span class="line">&gt; 0x00007FF670F2478B push rax</span><br><span class="line">&gt; 0x00007FF670F27A53 push rbx</span><br><span class="line">&gt; 0x00007FF670F2500D push r15</span><br><span class="line">&gt; 0x00007FF670F26030 push [0x00007FF670F27912]</span><br><span class="line">&gt; 0x00007FF670F2593A mov rax, 0x7FF530F20000</span><br><span class="line">&gt; 0x00007FF670F25955 mov r13, rax</span><br><span class="line">&gt; 0x00007FF670F25965 push rax</span><br><span class="line">&gt; 0x00007FF670F2596F mov esi, [rsp+0xA0]</span><br><span class="line">&gt; 0x00007FF670F25979 not esi</span><br><span class="line">&gt; 0x00007FF670F25985 neg esi</span><br><span class="line">&gt; 0x00007FF670F2598D ror esi, 0x1A</span><br><span class="line">&gt; 0x00007FF670F2599E mov rbp, rsp</span><br><span class="line">&gt; 0x00007FF670F259A8 sub rsp, 0x140</span><br><span class="line">&gt; 0x00007FF670F259B5 and rsp, 0xFFFFFFFFFFFFFFF0</span><br><span class="line">&gt; 0x00007FF670F259C1 mov rdi, rsp</span><br><span class="line">&gt; 0x00007FF670F259CB lea r12, [0x00007FF670F26473]</span><br><span class="line">&gt; 0x00007FF670F259DF mov rax, 0x100000000</span><br><span class="line">&gt; 0x00007FF670F259EC add rsi, rax</span><br><span class="line">&gt; 0x00007FF670F259F3 mov rbx, rsi</span><br><span class="line">&gt; 0x00007FF670F259FA add rsi, [rbp]</span><br><span class="line">&gt; 0x00007FF670F25A05 mov al, [rsi]</span><br><span class="line">&gt; 0x00007FF670F25A0A xor al, bl</span><br><span class="line">&gt; 0x00007FF670F25A11 neg al</span><br><span class="line">&gt; 0x00007FF670F25A19 rol al, 0x05</span><br><span class="line">&gt; 0x00007FF670F25A26 inc al</span><br><span class="line">&gt; 0x00007FF670F25A2F xor bl, al</span><br><span class="line">&gt; 0x00007FF670F25A34 movzx rax, al</span><br><span class="line">&gt; 0x00007FF670F25A41 mov rdx, [r12+rax*8]</span><br><span class="line">&gt; 0x00007FF670F25A49 xor rdx, 0x7F3D2149</span><br><span class="line">&gt; 0x00007FF670F25507 inc rsi</span><br><span class="line">&gt; 0x00007FF670F27951 add rdx, r13</span><br><span class="line">&gt; 0x00007FF670F27954 jmp rdx</span><br><span class="line">&gt; located vm handler table... at = 0x00007FF670F26473, rva = 0x0000000140006473</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到vmprofiler-cli已经对vm_entry代码进行了扁平化和去模糊化处理，并找到了vm handler表。我们还可以看到为解密vm handler实体所做的转换，它是在mov rdx, [r12+rax*8]之后的直接XOR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x00007FF670F25A41 mov rdx, [r12+rax*8]</span><br><span class="line">&gt; 0x00007FF670F25A49 xor rdx, 0x7F3D2149</span><br></pre></td></tr></table></figure>

<p>我们还可以看到，由于RSI被INC指令递增，VIP的进展是积极的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0x00007FF670F25507 inc rsi</span><br></pre></td></tr></table></figure>

<p>有了这些信息，我们现在可以编译一个vmtracer程序，它将把所有的vm处理程序表条目修补到我们的陷阱处理程序中，这将使我们能够跟踪虚拟指令以及改变虚拟指令的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambdas to encrypt and decrypt vm handler entries</span></span><br><span class="line"><span class="comment">// you must extract this information from the flattened </span></span><br><span class="line"><span class="comment">// and deobfuscated view of vm_entry…</span></span><br><span class="line"></span><br><span class="line">vm::<span class="type">decrypt_handler_t</span> _decrypt_handler =</span><br><span class="line">[](u64 val) -&gt; u64</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val ^ <span class="number">0x7F3D2149</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm::<span class="type">encrypt_handler_t</span> _encrypt_handler =</span><br><span class="line">[](u64 val) -&gt; u64</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val ^ <span class="number">0x7F3D2149</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm::handler::<span class="type">edit_entry_t</span> _edit_entry =</span><br><span class="line">[](u64* entry_ptr, u64 val) -&gt; <span class="type">void</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD old_prot;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(entry_ptr, <span class="keyword">sizeof</span> val,</span><br><span class="line">        PAGE_EXECUTE_READWRITE, &amp;old_prot);</span><br><span class="line"></span><br><span class="line">    *entry_ptr = val;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(entry_ptr, <span class="keyword">sizeof</span> val,</span><br><span class="line">        old_prot, &amp;old_prot);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create vm trace file header...</span></span><br><span class="line">vmp2::file_header trace_header;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;trace_header.magic, <span class="string">&quot;VMP2&quot;</span>, <span class="keyword">sizeof</span> <span class="string">&quot;VMP2&quot;</span> - <span class="number">1</span>);</span><br><span class="line">trace_header.epoch_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">trace_header.entry_offset = <span class="keyword">sizeof</span> trace_header;</span><br><span class="line">trace_header.advancement = vmp2::<span class="type">exec_type_t</span>::forward;</span><br><span class="line">trace_header.version = vmp2::<span class="type">version_t</span>::v1;</span><br><span class="line">trace_header.module_base = module_base;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我省略了一些其他的代码，如ofstream代码和vmtracer类实例化，你可以在这里找到这些代码。显示这些信息的主要目的是告诉你如何解析一个vm_entry并提取创建跟踪所需的信息。</p>
<p>在我的演示追踪器中，我只是简单地将受保护的二进制文件LoadLibraryExA，初始化一个vmtracer类，修补vm处理程序表，然后调用模块的入口点。这不是很理想，但对于演示目的来说，这就足够了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// patch vm handler table...</span></span><br><span class="line">tracer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// call entry point...</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">int</span> (*)()&gt;(</span><br><span class="line">    <span class="built_in">NT_HEADER</span>(module_base)-&gt;OptionalHeader.AddressOfEntryPoint + module_base)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpatch vm handler table...</span></span><br><span class="line">tracer.<span class="built_in">stop</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在已经创建了一个跟踪文件，我们现在可以通过vmprofiler-cli或vmprofiler-qt来检查跟踪。 不过我建议使用后者，因为这个程序是明确为查看跟踪文件而创建的。</p>
<p>当把跟踪文件加载到vmprofiler-qt中时，必须知道vm_entry RVA以及在PE文件的可选头中发现的镜像基础。考虑到所有这些信息以及原始的受保护二进制文件，vmprofiler-qt将显示跟踪文件中的所有虚拟指令，并允许你 “单步 “通过它。</p>
<p>让我们看一下这个跟踪文件，看看我们是否能找到原来的指令，这些指令现在已经被转换为基于RISC、堆栈机的架构。在vm_entry之后执行的第一个代码块似乎不包含与原始二进制文件有关的代码。它在这里只是为了混淆视听，防止对虚拟指令进行静态分析，因为要了解虚拟JMP指令的落点，需要对虚拟指令集进行仿真。这第一个跳转块位于每个受保护的二进制文件中。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/11.png"></p>
<p>在虚拟JMP指令之后的下一个块做了一些与堆栈有关的有趣的数学运算。如果你仔细观察，你可以看到正在执行的数学运算是：<code>sub(x, y) = ~((~(x) &amp; ~(x)) + y) &amp; ~((~(x) &amp; ~(x)) + y); sub(VSP, 10)</code>。</p>
<p>如果我们简化这个数学操作，我们可以看到这个操作是对VSP做的减法。<code>sub(x, y) = ~((~x) + y)</code>。这等同于本地操作<code>sub rsp, 0x10</code>。如果我们看一下原始的二进制，也就是没有被虚拟化的二进制，我们可以看到事实上有这个指令。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/12.png"></p>
<p>在虚拟指令中可以看到上面显示的MOV EAX, 1紧随在VSP上做的减法之后。MOV EAX, 1是通过一个LCONSTBSX和一个SREGDW完成的。SREG的位数与本地寄存器的宽度32bits相匹配，同时也与被加载的常数值相匹配。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/13.png"></p>
<p>接下来我们看到一个vmexit发生了。我们可以通过查看vmexit之前的最后一个ADDQ来了解代码执行在虚拟机之外的情况。堆栈上的前两个值应该是模块的基本地址和将被返回的例程的32位相对虚拟地址。在这个跟踪中，RVA是0x140008236。如果我们在IDA中检查这个地址，我们可以看到指令 “CPUID “在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vmp0:0000000140008236 0F A2                                         cpuid</span><br><span class="line">.vmp0:0000000140008238 0F 81 88 FE FF FF                             jno     loc_1400080C6</span><br><span class="line">.vmp0:000000014000823E 68 05 02 00 79                                push    79000205h</span><br><span class="line">.vmp0:0000000140008243 E9 77 FD FF FF                                jmp     loc_140007FBF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如你所看到的，在CPUID指令之后，代码执行直接回到了虚拟机中。在用位于虚拟堆栈上的本地寄存器值设置所有的虚拟scratch寄存器后，直接将一个常数加载到堆栈中，其值为0x1C。然后，CPUID的结果值被这个常数移到了右边。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/14.png"></p>
<p>AND操作是通过两个NAND操作完成的。第一个NAND操作简单地反转了SHR的结果；<code>invert(x) = ~(x) &amp; ~(x)</code>。这是通过将DWORD值两次加载到堆栈中来完成的，以形成一个QWORD。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/15.png"></p>
<p>这个AND操作的结果将被设置到虚拟scratch寄存器7（SREGDW 0x38）。然后，它被移到scratch寄存器16中。如果我们看一下vmexit指令和LREGQ的执行顺序，我们可以看到这确实是正确的。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/16.png"></p>
<p>最后，我们还可以看到ADD指令和LVSP指令向VSP增加了一个值。这是预料之中的，因为在原始二进制中存在一个ADD RSP，0x10。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/17.png"></p>
<p>从上面的信息我们可以重建以下的本地指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 0x10</span><br><span class="line">mov eax, 1</span><br><span class="line">cpuid</span><br><span class="line">shr ecx, 0x1C</span><br><span class="line">and ecx, 1</span><br><span class="line">mov eax, ecx ; from the LREGDW 0x38; SREGDW 0x80...</span><br><span class="line">add rsp, 0x10</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如你所看到的，有几条指令被遗漏了，特别是RBX的push’s和pop’s，以及XOR将ECX的内容清零。我认为这些指令没有直接转换为虚拟指令，而是以一种迂回的方式实现。</p>
<h1 id="改变虚拟指令的结果"><a href="#改变虚拟指令的结果" class="headerlink" title="改变虚拟指令的结果"></a>改变虚拟指令的结果</h1><p>为了改变虚拟指令，必须首先重新实现整个vm处理程序。如果vm处理程序对第二个操作数进行解密，必须记住解密密钥有效性的重要性。因此，必须计算出原始的即时值，并通过原始转换应用到解密密钥上。然而，在更新解密密钥后，这个值可以随后被丢弃。这方面的一个例子可以是改变上节中SHR之前的LCONST的常数值。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/18.png"></p>
<p>这个虚拟指令有两个操作数，第一个是要执行的vm handler索引，第二个是即时值，在这个例子中是一个单字节。由于有两个操作数，所以在vm处理程序中会有五个转换。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/19.png"></p>
<p>我们可以重新编码这个vm处理程序，将解密后的即时值与0x1C进行比较，然后分支到一个子程序，将一个不同的值加载到堆栈。这将导致SHR计算一个不同的结果。本质上我们可以欺骗CPUID的结果。另一种方法是重新创建SHR处理程序，然而为了简单起见，我只是要转移到一个被设置的位。在这种情况下，如果支持VMX，CPUID之后的ECX第5位将被设置，由于我的CPU支持虚拟化，这个位将是高的。下面是新的vm处理程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">    __mbase dq 0h</span><br><span class="line">    public __mbase</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">__lconstbzx proc</span><br><span class="line">    mov al, [rsi]</span><br><span class="line">    lea rsi, [rsi+1]</span><br><span class="line">    xor al, bl</span><br><span class="line">    dec al</span><br><span class="line">    ror al, 1</span><br><span class="line">    neg al</span><br><span class="line">    xor bl, al</span><br><span class="line"></span><br><span class="line">    pushfq            ; save flags...</span><br><span class="line">    cmp ax, 01Ch</span><br><span class="line">    je swap_val</span><br><span class="line"></span><br><span class="line">                    ; the constant is not 0x1C</span><br><span class="line">    popfq            ; restore flags...     </span><br><span class="line">    sub rbp, 2</span><br><span class="line">    mov [rbp], ax</span><br><span class="line">    mov rax, __mbase</span><br><span class="line">    add rax, 059FEh    ; calc jmp rva is 0x59FE...</span><br><span class="line">    jmp rax</span><br><span class="line"></span><br><span class="line">swap_val:            ; the constant is 0x1C</span><br><span class="line">    popfq            ; restore flags...</span><br><span class="line">    mov ax, 5        ; bit 5 is VMX in ECX after CPUID...</span><br><span class="line">    sub rbp, 2</span><br><span class="line">    mov [rbp], ax</span><br><span class="line">    mov rax, __mbase</span><br><span class="line">    add rax, 059FEh    ; calc jmp rva is 0x59FE...</span><br><span class="line">    jmp rax</span><br><span class="line">__lconstbzx endp</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们现在再次运行vm tracer，将这个新的vm处理程序设置为索引0x55，我们应该能够看到LCONSTBZX的变化。为了方便这个钩子，我们必须把新的vm处理程序的虚拟地址设置为vm::handler::table_t对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// change vm handler 0x55 (LCONSTBZX) to our implimentation of it…</span><br><span class="line">auto _meta_data = handler_table.get_meta_data(0x55);</span><br><span class="line">_meta_data.virt = reinterpret_cast&lt;u64&gt;(&amp;__lconstbzx);</span><br><span class="line">handler_table.set_meta_data(0x55, _meta_data);</span><br></pre></td></tr></table></figure>

<p>如果我们现在运行二进制，它将返回1。你可以在下面看到这个。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/20.png"></p>
<h1 id="编码虚拟指令-逆向转换"><a href="#编码虚拟指令-逆向转换" class="headerlink" title="编码虚拟指令 - 逆向转换"></a>编码虚拟指令 - 逆向转换</h1><p>由于VMProtect 2生成的虚拟机执行的是以其自身字节码编码的虚拟指令，因此，如果能够对其进行编码，就可以在虚拟机上运行自己的虚拟指令。编码的虚拟指令也必须在4GB的地址空间范围内，因为虚拟指令的RVA是32bits宽。在本节中，我将编码一组非常简单的虚拟指令，将两个QWORD值相加并返回结果。</p>
<p>首先，对虚拟指令进行编码需要在二进制文件中加入上述虚拟指令的vm处理程序。通过’vmprofiler’来定位这些vm处理程序。vm处理程序的索引是第一个操作码，即时值（如果有的话）是第二个。结合这两组操作数将产生一个编码的虚拟指令。这是组装虚拟指令的第一阶段，第二阶段是对操作数进行加密。</p>
<p>一旦我们有了编码的虚拟指令，我们现在就可以使用vm handler变换的逆操作以及calc_jmp的逆操作来加密它们。值得注意的是，在加密时必须考虑到VIP的推进方式，因为操作数和虚拟指令的顺序取决于这个推进方向。</p>
<p><img src="/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/21.png"></p>
<p>为了执行这些新装配的虚拟指令，必须把虚拟指令放在vm_entry例程的32位地址范围内，然后把这些虚拟指令的加密rva放到堆栈中，最后再调用到vm_entry。我建议使用VirtualAllocEx在受保护模块的正下方分配一个RW页面。下面显示了一个运行虚拟指令的例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SIZE_T bytes_copied;</span><br><span class="line">STARTUPINFOA info = &#123; <span class="keyword">sizeof</span> info &#125;;</span><br><span class="line">PROCESS_INFORMATION proc_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the protected binary suspended...</span></span><br><span class="line"><span class="comment">// keep in mind this binary is not packed...</span></span><br><span class="line"><span class="built_in">CreateProcessA</span>(<span class="string">&quot;vmptest.vmp.exe&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="literal">false</span>,</span><br><span class="line">    CREATE_SUSPENDED | CREATE_NEW_CONSOLE,</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;info, &amp;proc_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for the system to finish setting up...</span></span><br><span class="line"><span class="built_in">WaitForInputIdle</span>(proc_info.hProcess, INFINITE);</span><br><span class="line"><span class="keyword">auto</span> module_base = <span class="built_in">get_process_base</span>(proc_info.hProcess);</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate space for the virtual instructions below the module...</span></span><br><span class="line"><span class="keyword">auto</span> virt_instrs = <span class="built_in">VirtualAllocEx</span>(proc_info.hProcess,</span><br><span class="line">    module_base + vmasm-&gt;header-&gt;offset,</span><br><span class="line">    vmasm-&gt;header-&gt;size,</span><br><span class="line">    MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the virtual instructions...</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(proc_info.hProcess, virt_instrs,</span><br><span class="line">    vmasm-&gt;data, vmasm-&gt;header-&gt;size, &amp;bytes_copied);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a thread to run the virtual instructions...</span></span><br><span class="line"><span class="keyword">auto</span> thandle = <span class="built_in">CreateRemoteThread</span>(proc_info.hProcess,</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="number">0u</span>,</span><br><span class="line">    module_base + vm_entry_rva,</span><br><span class="line">    <span class="literal">nullptr</span>, CREATE_SUSPENDED, &amp;tid);</span><br><span class="line"></span><br><span class="line">CONTEXT thread_ctx;</span><br><span class="line"><span class="built_in">GetThreadContext</span>(thandle, &amp;thread_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub rsp, 8...</span></span><br><span class="line">thread_ctx.Rsp -= <span class="number">8</span>;</span><br><span class="line">thread_ctx.Rip = module_base + vm_entry_rva;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write encrypted rva onto the stack...</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(proc_info.hProcess, thread_ctx.Rsp,</span><br><span class="line">    &amp;vmasm-&gt;header-&gt;encrypted_rva,</span><br><span class="line">    <span class="keyword">sizeof</span> vmasm-&gt;header-&gt;encrypted_rva, &amp;bytes_copied);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update thread context and resume execution...</span></span><br><span class="line"><span class="built_in">SetThreadContext</span>(thandle, &amp;thread_ctx);</span><br><span class="line"><span class="built_in">ResumeThread</span>(thandle);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="结论-静态分析，动态分析"><a href="#结论-静态分析，动态分析" class="headerlink" title="结论 - 静态分析，动态分析"></a>结论 - 静态分析，动态分析</h1><p>最后，我的动态分析方案不是最理想的方案，但是它应该允许对受保护的二进制文件进行基本的反向工程。随着时间的推移，对虚拟指令的静态分析将成为可能，然而目前动态分析将不得不做。在未来，我将使用unicorn来模拟虚拟机的处理程序。</p>
<p>尽管我已经记录了少数的虚拟指令，但还有更多的指令没有被记录。我记录这些虚拟指令的目的是让本文的读者获得一种感觉，即虚拟机处理程序应该是什么样子，以及如何改变这些虚拟机处理程序的结果。本文中记录的虚拟指令也是最常见的。这些虚拟指令很可能会出现在每个虚拟机中。</p>
<p>我在资源库中添加了一些参考构建，供你尝试通过改变虚拟机处理程序使它们返回1。还有一个构建是在一个二进制文件中使用多个虚拟机。</p>
<p>最后，我想重申，这项研究肯定已经由私人实体完成，我不是第一个记录这篇文章中讨论的一些虚拟机架构的人。我已经记下了那些我已经研究过的人的名字，但是可能还有很多人已经做了关于VMProtect 2的研究，我没有列出，只是因为我没有遇到过他们的工作。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li>
        
          <li><a href="/books/">Books</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%91%E6%96%87-VMProtect2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">[译文]VMProtect2-虚拟机架构的详细分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Credit-Links-to-Exiiting-Work"><span class="toc-number">2.</span> <span class="toc-text">Credit - Links to Exiiting Work</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E8%A8%80-%E6%84%8F%E5%9B%BE%E5%92%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">序言 - 意图和目的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">3.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">意图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86-Deadstore%EF%BC%8C%E4%B8%8D%E9%80%8F%E6%98%8E%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">6.</span> <span class="toc-text">混淆-Deadstore，不透明的分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E5%88%86%E6%94%AF%E6%B7%B7%E6%B7%86%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">不透明分支混淆实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deadstore-%E6%B7%B7%E6%B7%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">Deadstore 混淆示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-VMProtect-2-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">概述 - VMProtect 2 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%BC%8F%E8%A7%A3%E5%AF%86"><span class="toc-number">7.1.</span> <span class="toc-text">滚动式解密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">本地寄存器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8%E2%80%93%E6%9C%89%E7%89%B9%E5%AE%9A%E7%94%A8%E9%80%94%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">非易失性寄存器–有特定用途的寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E5%A4%B1%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8-%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">易失性寄存器 - 临时寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-entry-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">vm_entry - 虚拟机的入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#calc-jmp-%E8%A7%A3%E5%AF%86Vm-Handler%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">calc_jmp - 解密Vm Handler的索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-exit-%E7%A6%BB%E5%BC%80%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.5.</span> <span class="toc-text">vm_exit - 离开虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#check-vsp-%E9%87%8D%E5%AE%9A%E4%BD%8Dscratch%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.6.</span> <span class="toc-text">check_vsp - 重定位scratch寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4-%E6%93%8D%E4%BD%9C%E7%A0%81%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E3%80%81%E8%A7%84%E6%A0%BC"><span class="toc-number">7.7.</span> <span class="toc-text">虚拟指令 - 操作码、操作数、规格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A7%A3%E5%AF%86-Transformations"><span class="toc-number">7.7.1.</span> <span class="toc-text">操作符解密 - Transformations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-Handlers-%E8%A7%84%E6%A0%BC"><span class="toc-number">7.8.</span> <span class="toc-text">VM Handlers - 规格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LCONST-%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%B8%B8%E9%87%8F%E5%80%BC"><span class="toc-number">7.8.1.</span> <span class="toc-text">LCONST - 在堆栈中加载常量值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTQ-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0QWORD"><span class="toc-number">7.8.1.1.</span> <span class="toc-text">LCONSTQ - 加载常数QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCDQE-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0DWORD%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95%E5%88%B0%E4%B8%80%E4%B8%AAQWORD"><span class="toc-number">7.8.1.2.</span> <span class="toc-text">LCONSTCDQE - 加载常数DWORD符号扩展到一个QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCBW-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0%E5%AD%97%E8%8A%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97"><span class="toc-number">7.8.1.3.</span> <span class="toc-text">LCONSTCBW - 加载常数字节转换为字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTCWDE-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BADWORD"><span class="toc-number">7.8.1.4.</span> <span class="toc-text">LCONSTCWDE - 加载常数字转换为DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LCONSTDW-%E5%8A%A0%E8%BD%BD%E5%B8%B8%E6%95%B0DWORD"><span class="toc-number">7.8.1.5.</span> <span class="toc-text">LCONSTDW - 加载常数DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LREG-%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%AD%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC"><span class="toc-number">7.8.2.</span> <span class="toc-text">LREG - 在堆栈中加载Scratch寄存器的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LREGQ-%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8QWORD"><span class="toc-number">7.8.2.1.</span> <span class="toc-text">LREGQ - 加载Scratch寄存器QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LREGDW-%E5%8A%A0%E8%BD%BDScratch%E5%AF%84%E5%AD%98%E5%99%A8DWORD"><span class="toc-number">7.8.2.2.</span> <span class="toc-text">LREGDW - 加载Scratch寄存器DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SREG-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC"><span class="toc-number">7.8.3.</span> <span class="toc-text">SREG - 设置Scratch寄存器值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGQ-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCQWORD"><span class="toc-number">7.8.3.1.</span> <span class="toc-text">SREGQ - 设置Scratch寄存器值QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGDW-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCDWORD"><span class="toc-number">7.8.3.2.</span> <span class="toc-text">SREGDW - 设置Scratch寄存器值DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGW-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BCWORD"><span class="toc-number">7.8.3.3.</span> <span class="toc-text">SREGW - 设置Scratch寄存器值WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SREGB-%E8%AE%BE%E7%BD%AEScratch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%80%BC"><span class="toc-number">7.8.3.4.</span> <span class="toc-text">SREGB - 设置Scratch寄存器的字节值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD-%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.</span> <span class="toc-text">ADD - 两个值相加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDQ-%E4%B8%A4%E4%B8%AAQWORD%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.1.</span> <span class="toc-text">ADDQ - 两个QWORD值相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDW-%E4%B8%A4%E4%B8%AAWORDS%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.2.</span> <span class="toc-text">ADDW - 两个WORDS值相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADDB-%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">7.8.4.3.</span> <span class="toc-text">ADDB - 两个字节的值相加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MUL-%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="toc-number">7.8.5.</span> <span class="toc-text">MUL - 无符号乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MULQ-QWORD%E7%9A%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="toc-number">7.8.5.1.</span> <span class="toc-text">MULQ - QWORD的无符号乘法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIV-%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">7.8.6.</span> <span class="toc-text">DIV - 无符号除法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DIVQ-QWORD%E7%9A%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">7.8.6.1.</span> <span class="toc-text">DIVQ - QWORD的无符号除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#READ-%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98"><span class="toc-number">7.8.7.</span> <span class="toc-text">READ - 读取内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#READQ-%E8%AF%BB%E5%8F%96QWORD"><span class="toc-number">7.8.7.1.</span> <span class="toc-text">READQ - 读取QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READDW-%E8%AF%BB%E5%8F%96DWORD"><span class="toc-number">7.8.7.2.</span> <span class="toc-text">READDW - 读取DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READW-%E8%AF%BB%E5%8F%96%E5%AD%97"><span class="toc-number">7.8.7.3.</span> <span class="toc-text">READW - 读取字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WRITE-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-number">7.8.8.</span> <span class="toc-text">WRITE - 写入内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEQ-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98QWORD"><span class="toc-number">7.8.8.1.</span> <span class="toc-text">WRITEQ - 写入内存QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEDW-%E5%86%99%E5%85%A5DWORD"><span class="toc-number">7.8.8.2.</span> <span class="toc-text">WRITEDW - 写入DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEW-%E5%86%99%E5%85%A5WORD"><span class="toc-number">7.8.8.3.</span> <span class="toc-text">WRITEW - 写入WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITEB-%E5%86%99%E5%85%A5%E5%AD%97%E8%8A%82"><span class="toc-number">7.8.8.4.</span> <span class="toc-text">WRITEB - 写入字节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHL-%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.</span> <span class="toc-text">SHL - 左移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLCBW-%E5%B7%A6%E7%A7%BB%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%9C%E4%B8%BAWORD"><span class="toc-number">7.8.9.1.</span> <span class="toc-text">SHLCBW - 左移转换结果为WORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLW-WORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.2.</span> <span class="toc-text">SHLW - WORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLDW-DWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.3.</span> <span class="toc-text">SHLDW - DWORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLQ-QWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.4.</span> <span class="toc-text">SHLQ - QWORD左移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLD-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.5.</span> <span class="toc-text">SHLD - 双精度左移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SHLDQ-%E5%90%91%E5%B7%A6%E7%A7%BB%E5%8A%A8%E5%8F%8C%E7%B2%BE%E5%BA%A6QWORD"><span class="toc-number">7.8.9.5.1.</span> <span class="toc-text">SHLDQ - 向左移动双精度QWORD</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHLDDW-%E5%8F%8C%E7%B2%BE%E5%BA%A6DWORD%E5%B7%A6%E7%A7%BB"><span class="toc-number">7.8.9.6.</span> <span class="toc-text">SHLDDW - 双精度DWORD左移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHR-%E5%8F%B3%E7%A7%BB"><span class="toc-number">7.8.10.</span> <span class="toc-text">SHR - 右移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRQ-%E5%8F%B3%E7%A7%BBQWORD"><span class="toc-number">7.8.10.1.</span> <span class="toc-text">SHRQ - 右移QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRD-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BB"><span class="toc-number">7.8.10.2.</span> <span class="toc-text">SHRD - 双精度右移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRDQ-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BBQWORD"><span class="toc-number">7.8.10.3.</span> <span class="toc-text">SHRDQ - 双精度右移QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHRDDW-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%8F%B3%E7%A7%BBDWORD"><span class="toc-number">7.8.10.4.</span> <span class="toc-text">SHRDDW - 双精度右移DWORD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAND-Not-Then-And"><span class="toc-number">7.8.11.</span> <span class="toc-text">NAND - Not Then And</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NANDW-%E4%B8%8D%E6%98%AF%E7%84%B6%E5%90%8E%E5%92%8CWORD%E7%9A%84"><span class="toc-number">7.8.11.1.</span> <span class="toc-text">NANDW - 不是然后和WORD的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READCR3-%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A83"><span class="toc-number">7.8.11.2.</span> <span class="toc-text">READCR3 - 读取控制寄存器3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WRITECR3-%E5%86%99%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A83"><span class="toc-number">7.8.11.3.</span> <span class="toc-text">WRITECR3 - 写控制寄存器3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PUSHVSP-Push%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">7.8.12.</span> <span class="toc-text">PUSHVSP - Push虚拟堆栈指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSHVSPQ-Push%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88QWORD"><span class="toc-number">7.8.12.1.</span> <span class="toc-text">PUSHVSPQ - Push虚拟堆栈指针QWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSHVSPDW-%E6%8E%A8%E9%80%81%E8%99%9A%E6%8B%9F%E6%A0%88%E6%8C%87%E9%92%88DWORD"><span class="toc-number">7.8.12.2.</span> <span class="toc-text">PUSHVSPDW - 推送虚拟栈指针DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSVSPW-%E6%8E%A8%E9%80%81%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E7%9A%84WORD%E5%80%BC"><span class="toc-number">7.8.12.3.</span> <span class="toc-text">PUSVSPW - 推送虚拟堆栈指针的WORD值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVSP-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">7.8.13.</span> <span class="toc-text">LVSP - 加载虚拟堆栈指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LVSPW-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88%E5%AD%97"><span class="toc-number">7.8.13.1.</span> <span class="toc-text">LVSPW - 加载虚拟堆栈指针字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LVSPDW-%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88DWORD"><span class="toc-number">7.8.13.2.</span> <span class="toc-text">LVSPDW - 加载虚拟堆栈指针DWORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRFLAGS-%E5%8A%A0%E8%BD%BDRFLAGS"><span class="toc-number">7.8.13.3.</span> <span class="toc-text">LRFLAGS - 加载RFLAGS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMP-%E8%99%9A%E6%8B%9F%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">7.8.14.</span> <span class="toc-text">JMP - 虚拟跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALL-%E8%99%9A%E6%8B%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">7.8.15.</span> <span class="toc-text">CALL - 虚拟调用指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AD%BE%E5%90%8D-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">重要的虚拟机签名 - 静态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%A1%A8"><span class="toc-number">8.1.</span> <span class="toc-text">定位虚拟机处理程序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%A1%A8%E6%9D%A1%E7%9B%AE%E8%A7%A3%E5%AF%86"><span class="toc-number">8.2.</span> <span class="toc-text">定位虚拟机处理程序表条目解密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BD%AC%E6%8D%A2%E2%80%93%E6%A8%A1%E6%9D%BF%E5%8C%96%E7%9A%84Lambdas%E5%92%8CMaps"><span class="toc-number">8.3.</span> <span class="toc-text">处理转换–模板化的Lambdas和Maps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E8%BD%AC%E6%8D%A2-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%BB%A7%E7%BB%AD"><span class="toc-number">8.3.1.</span> <span class="toc-text">提取转换 - 静态分析继续</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E5%9B%B0%E5%A2%83-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E7%BB%93%E8%AE%BA"><span class="toc-number">8.4.</span> <span class="toc-text">静态分析的困境 - 静态分析的结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vmtracer-%E8%BF%BD%E8%B8%AA%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">8.4.1.</span> <span class="toc-text">vmtracer - 追踪虚拟指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmprofile-cli-%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B7%9F%E8%B8%AA%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">8.4.2.</span> <span class="toc-text">vmprofile-cli - 使用运行时跟踪的静态分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF-vmprofiler-qt"><span class="toc-number">9.</span> <span class="toc-text">显示跟踪信息 - vmprofiler-qt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">10.</span> <span class="toc-text">虚拟机的行为</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E8%B7%9F%E8%B8%AA"><span class="toc-number">11.</span> <span class="toc-text">Demo - 创建和检查一个虚拟跟踪</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">12.</span> <span class="toc-text">改变虚拟指令的结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4-%E9%80%86%E5%90%91%E8%BD%AC%E6%8D%A2"><span class="toc-number">13.</span> <span class="toc-text">编码虚拟指令 - 逆向转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">14.</span> <span class="toc-text">结论 - 静态分析，动态分析</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&text=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&is_video=false&description=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[译文]VMProtect2-虚拟机架构的详细分析&body=Check out this article: http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&title=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&name=[译文]VMProtect2-虚拟机架构的详细分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://tugohost.github.io.com/2022/12/06/VMProtect2_detailed_analysis_of_the_virtual_machine_architecture/&t=[译文]VMProtect2-虚拟机架构的详细分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2023
    TUGOhost
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/TUGOhost">Projects</a></li><!--
     --><!--
       --><li><a href="/books/">Books</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
